# Methods in Java:

## What is a Method?

In Java, a **method** is a reusable block of code that performs a specific task or operation. Methods are the fundamental means by which behavior is defined in object-oriented programming, encapsulating code functionality and allowing for the abstraction of complex operations. Every method has a name, a return type (which can be `void` if it returns nothing), and can optionally accept input parameters.

By using methods, a programmer can avoid redundant code, improve readability, and create modular programs where each piece of behavior is logically isolated. Methods may be called multiple times throughout a program, potentially with different inputs, producing relevant outputs or side effects such as printing messages or modifying object states.

***

## Why Use Methods?

Methods are essential in programming for several fundamental reasons:

- **Code Reusability:** Write once, use many times. Methods encapsulate common tasks to be reused.
- **Modularity:** Large programs are broken down into smaller methods, each handling specific functionality.
- **Maintainability:** Changes are localized to method definitions without impacting entire codebase.
- **Readability:** Methods with descriptive names explain program logic clearly.
- **Parameterization:** Methods accept inputs to customize behavior dynamically during execution.
- **Encapsulation:** Methods expose well-defined interfaces while hiding implementation details.

Together, these attributes make methods the building blocks for scalable, maintainable, and readable programs in Java and most programming languages.

***

## Anatomy of a Method

```java
returnType methodName(parameterList) {
    // body: the executable code
}
```

- **returnType:** Specifies what data type the method will return (use `void` if no return).
- **methodName:** Identifier used to invoke this method.
- **parameterList:** Comma-separated list of typed inputs (can be empty).
- **method body:** The set of statements executed when the method is called.

***

## Basic Example: Adding Two Numbers

```java
public class Calculator {
    int add(int a, int b) {
        int sum = a + b;
        return sum;
    }
}
```

- Here, `add` takes two integer parameters and returns their sum.
- The addition operation is encapsulated inside the method body.
- The method can be called multiple times with different inputs.

***

## Step-by-Step Method Execution with Visuals

Calling `int result = calc.add(7, 3);`:

```
Stack frame for main:
+-------------------------+
| result = ?              |
| calls add(7, 3) --------> stack frame for add method
+-------------------------+

Stack frame for add:
+-------------------------+
| a = 7                   |
| b = 3                   |
| sum = a + b = 10        |
| return 10               |
+-------------------------+

Back to main:
+-------------------------+
| result = 10             |
+-------------------------+
```

- Each method call pushes a frame on the stack holding parameters and local variables.
- Returning from the method pops the frame and places the return value in caller’s context.

***

## Instance Methods

Instance methods belong to objects and usually operate on instance variables. They require an object reference to be invoked.

Example:

```java
class Person {
    String name;
    void greet() {
        System.out.println("Hello, " + name);
    }
}
```

Calling:

```java
Person p = new Person();
p.name = "Alice";
p.greet();  // Prints: Hello, Alice
```

Instance methods can access and modify object states, enabling encapsulated behavior per object instance.

***

## Static Methods

Unlike instance methods, static methods belong to the class itself, not an object. They cannot access instance variables directly and are called without needing an instance.

Example:

```java
class MathUtil {
    static int square(int x) {
        return x * x;
    }
}
int sq = MathUtil.square(5);  // 25
```

Use static methods for utility or helper functionality unrelated to object state.

***

## Method Overloading

Java supports multiple methods of the same name distinguished by parameter types or counts.

Example:

```java
class Printer {
    void show(int a) { System.out.println(a); }
    void show(String s) { System.out.println(s); }
}

Printer p = new Printer();
p.show(10);      // prints 10
p.show("Hello"); // prints Hello
```

This allows intuitive method naming while handling different input scenarios.

***

## Void Methods

Void methods perform tasks but don’t return values.

Example:

```java
void printMessage() {
    System.out.println("Welcome!");
}
```

Used when no computation result is needed, e.g., for displaying output.

***

## Methods with Return Values

These methods return results via `return`, which can be captured by callers.

Example:

```java
int multiply(int x, int y) {
    return x * y;
}
```

Returning values enables chaining computations and storing results.

***

## Parameter Passing in Java: Call by Value

Java copies values into methods:

- For primitives, copies of values are passed.
- For objects, copies of references are passed (both point to same object).

Example:

```java
void modify(int n) { n = 10; }
int a = 5;
modify(a);
System.out.println(a);  // Prints 5 (original unaffected)
```


***

## Recursive Methods

Methods can call themselves to solve problems by breaking into smaller parts.

Example: Factorial

```java
int factorial(int n) {
    if (n == 0) return 1;
    else return n * factorial(n - 1);
}
```

Stack frames are created for each call and unwind after reaching the base case.

***

## Recursive Method Call Stack for factorial(3)

```
Stack frames (top to bottom):

| factorial(3) |
| factorial(2) |
| factorial(1) |
| factorial(0) |

Returns:

factorial(0) = 1
factorial(1) = 1 * 1 = 1
factorial(2) = 2 * 1 = 2
factorial(3) = 3 * 2 = 6
```


***

## Execution Flow in Memory:

```
Caller Stack (main):
+-------------------+
| result = ?        |
| call factorial(3) |
+-------------------+

Called factorial:
+---------------------+
| n = 3               |
| calls factorial(2)  |
+---------------------+

Call stack grows deeper until base case, then unwinds returning results.
```


***

## Summary Table of Method Concepts

| Concept | Description | Example |
| :-- | :-- | :-- |
| Instance Method | Called on object, accesses instance data | `obj.greet()` |
| Static Method | Called on class, no object needed | `MathUtil.square(5)` |
| Method Overloading | Same name, diff parameters | `print(int)` \& `print(String)` |
| Void Method | Performs action, no return | `void display()` |
| Return Method | Returns result to caller | `int add(int x, int y)` |
| Parameter Passing | Java passes copies of values | `modify(int n)` |
| Recursive Method | Calls itself to solve problem | `factorial(int n)` |


***
