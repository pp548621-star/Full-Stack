# 09. Next.js 15 App Router: Data Fetching (CSR, SSR, SSG, ISR) The Modern Way

This chapter mirrors everything you did with `pages/` (`getStaticProps`, `getServerSideProps`, `getStaticPaths`) and shows the **App Router equivalents** using `app/`, **Server Components**, and the built‑in `fetch` caching API.

---

## Quick Map: Pages Router → App Router

| Goal                  | Pages Router (legacy)           | App Router (Next.js 15)                                       |
| --------------------- | ------------------------------- | ------------------------------------------------------------- |
| SSG (build time)      | `getStaticProps`                | Default `fetch()` in a Server Component (cached)              |
| ISR (periodic re-gen) | `getStaticProps` + `revalidate` | `fetch(url, { next: { revalidate: N } })` in Server Component |
| SSR (per request)     | `getServerSideProps`            | `fetch(url, { cache: "no-store" })` in Server Component       |
| Dynamic routes        | `getStaticPaths`                | `generateStaticParams()`                                      |
| 404 and errors        | `pages/404.js`, `_error.js`     | `app/not-found.tsx`, `app/error.tsx`                          |
| Client-only logic     | normal React + hooks            | mark component `"use client"`                                 |
| Linking               | `next/link`                     | `next/link` (same)                                            |

All examples below assume a project created with `npx create-next-app@latest` and the **App Router** enabled.

---

## Project Structure (App Router)

```
app/
  layout.tsx
  page.tsx
  posts/
    page.tsx
  blogs/
    page.tsx
  ssr-posts/
    page.tsx
  products/
    [id]/
      page.tsx
  error.tsx
  not-found.tsx
public/
next.config.js
package.json
```

---

## 1) Client‑Side Rendering (CSR) in App Router

Use a **Client Component** by adding `"use client"`. This is ideal for user‑specific or highly interactive UI. CodingGita example: Arjun’s notifications list fetched after render.

```tsx
// app/csr-posts/page.tsx
"use client";

import { useEffect, useState } from "react";

export default function CSRPostsPage() {
  const [posts, setPosts] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function load() {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");
      const data = await res.json();
      setPosts(data.slice(0, 10));
      setLoading(false);
    }
    load();
  }, []);

  return (
    <main className="p-6">
      <h1 className="text-xl font-bold mb-4">CSR Example (App Router)</h1>
      {loading ? <p>Loading…</p> : (
        <ul className="space-y-2">
          {posts.map(p => <li key={p.id}>{p.title}</li>)}
        </ul>
      )}
    </main>
  );
}
```

Key points

* No special data‑fetching function; this is plain React on the client.
* Use CSR when SEO is not critical or data is per‑user and fast‑changing.

---

## 2) Server‑Side Rendering (SSR) in App Router

Use a **Server Component** (default) and set `cache: "no-store"` to fetch on every request. CodingGita example: Mahir’s live market widget.

```tsx
// app/ssr-posts/page.tsx
export default async function SSRPostsPage() {
  const res = await fetch("https://jsonplaceholder.typicode.com/posts", {
    cache: "no-store", // disable caching → always fresh
  });
  const posts = await res.json();

  return (
    <main className="p-6">
      <h1 className="text-xl font-bold mb-4">SSR Example (App Router)</h1>
      <ul className="space-y-2">
        {posts.slice(0, 5).map((p: any) => <li key={p.id}>{p.title}</li>)}
      </ul>
    </main>
  );
}
```

Key points

* No `getServerSideProps`. The server fetch happens inside the async Server Component.
* Best for always‑fresh, SEO‑visible pages.

---

## 3) Static Site Generation (SSG) in App Router

Simply call `fetch()` in a Server Component and let Next.js cache the response at build time (or first request with full caching). CodingGita example: Priyesha’s static blogs.

```tsx
// app/posts/page.tsx
export default async function PostsPage() {
  const res = await fetch("https://jsonplaceholder.typicode.com/posts");
  const posts = await res.json();

  return (
    <main className="p-6">
      <h1 className="text-xl font-bold mb-4">SSG Example (App Router)</h1>
      <ul className="space-y-2">
        {posts.slice(0, 10).map((p: any) => <li key={p.id}>{p.title}</li>)}
      </ul>
    </main>
  );
}
```

Key points

* No `getStaticProps`. Default `fetch()` is cached for static output.
* Ideal for rarely changing content with top performance and SEO.

---

## 4) Incremental Static Regeneration (ISR) in App Router

Set a revalidation window on `fetch`. CodingGita example: Krishna’s product grid that refreshes hourly.

```tsx
// app/blogs/page.tsx
export default async function BlogsPage() {
  const res = await fetch("https://jsonplaceholder.typicode.com/posts", {
    next: { revalidate: 30 }, // regenerate at most every 30s
  });
  const posts = await res.json();

  return (
    <main className="p-6">
      <h1 className="text-xl font-bold mb-2">ISR Example (App Router)</h1>
      <p className="text-sm text-gray-600">Revalidates every 30 seconds</p>
      <ul className="space-y-2 mt-4">
        {posts.slice(0, 5).map((p: any) => <li key={p.id}>{p.title}</li>)}
      </ul>
    </main>
  );
}
```

Key points

* No `revalidate` return value like Pages Router; it lives in `fetch(..., { next: { revalidate } })`.
* Regeneration is background and transparent to users.

---

## 5) Dynamic Routes and Pre‑Rendering (SSG + ISR)

In Pages Router you used `getStaticPaths`. In App Router you use `generateStaticParams()`.

CodingGita example: product details prebuilt for popular products, with reviews loading on the client.

```tsx
// app/products/[id]/page.tsx
import { Suspense } from "react";

// Client reviews widget (CSR)
function Reviews({ productId }: { productId: string }) {
  "use client";
  const [items, setItems] = React.useState<any[]>([]);
  React.useEffect(() => {
    fetch(`https://fakestoreapi.com/products/${productId}/reviews`)
      .then(r => r.json()).then(setItems);
  }, [productId]);
  return (
    <section>
      <h3 className="font-semibold mt-6 mb-2">Reviews</h3>
      {items.length ? items.map((r, i) => <p key={i}>{r.comment}</p>) : <p>Loading reviews…</p>}
    </section>
  );
}

export default async function ProductPage({ params }: { params: { id: string } }) {
  // ISR for product details
  const res = await fetch(`https://fakestoreapi.com/products/${params.id}`, {
    next: { revalidate: 60 },
  });
  if (!res.ok) {
    // Optional: throw to trigger `error.tsx` or call notFound()
    // notFound();
  }
  const product = await res.json();

  return (
    <main className="p-6">
      <h1 className="text-2xl font-bold">{product.title}</h1>
      <p className="mt-2">{product.description}</p>
      <Suspense fallback={<p>Loading reviews…</p>}>
        <Reviews productId={params.id} />
      </Suspense>
    </main>
  );
}

// Pre-generate a subset (SSG); similar spirit to getStaticPaths
export async function generateStaticParams() {
  const res = await fetch("https://fakestoreapi.com/products");
  const products = await res.json();
  return products.slice(0, 20).map((p: any) => ({ id: String(p.id) }));
}
```

Not‑found and error handling

* Add `app/not-found.tsx` to render a 404 page.
* Add `app/error.tsx` to catch and render errors for this route segment.

```tsx
// app/not-found.tsx
export default function NotFound() {
  return <main className="p-6">Page not found</main>;
}

// app/error.tsx
"use client";
export default function Error({ error }: { error: Error }) {
  return <main className="p-6">Something went wrong: {error.message}</main>;
}
```

---

## 6) Hybrid Rendering Patterns (Mix CSR + SSR + ISR + SSG)

* Static shell via SSG/ISR for SEO and speed.
* Critical freshness via SSR on specific sub‑requests (API routes, server actions, or `cache: "no-store"` fetches).
* Highly interactive widgets via CSR (`"use client"` components).
* For CodingGita, a course page could be SSG/ISR, while an enrolled student’s progress graph is CSR, and an admin inventory widget is SSR.

---

## 7) Which One Is Recommended?

For **new projects**:

* Prefer the **App Router**. Reasons:

  * Server Components by default reduce client JS and improve performance.
  * Built‑in caching and revalidation with `fetch` keeps APIs simple.
  * Co‑located layouts, nested routing, and streaming improve UX and developer experience.
  * First‑class SEO via `app/` metadata, `not-found.tsx`, `error.tsx`, and segment‑level control.
  * Future‑facing; most new features land here first.

For **existing projects on Pages Router**:

* You can keep using Pages Router if it works for you.
* Migrate gradually by adding an `app/` directory for new areas; both routers can coexist. App routes win on conflicts, so avoid overlapping paths.

When Pages Router is reasonable:

* You have a mature, stable codebase that would be costly to move right now.
* You rely on patterns that your team already standardized on (e.g., `getServerSideProps`) and migration can be staged.

---

## 8) Migration Tips (Pages → App)

* Start with non‑critical routes in `app/`.
* Replace `getStaticProps` with `fetch(..., { next: { revalidate } })`.
* Replace `getServerSideProps` with `fetch(..., { cache: "no-store" })`.
* Replace `getStaticPaths` with `generateStaticParams()`.
* Move shared layout from `_app.tsx` to `app/layout.tsx`. Use nested layouts for sections (e.g., `/dashboard`).
* Convert client pages incrementally: default to Server Components; mark interactive parts with `"use client"`.

---

## 9) Common Gotchas

* Over‑using `"use client"` makes you lose Server Component benefits. Keep client boundaries small (e.g., input forms, charts).
* Caching confusion:

  * Default `fetch` is cached (SSG).
  * `next.revalidate` enables ISR.
  * `cache: "no-store"` forces SSR.
* Route priority: if both routers define the same path, App Router’s wins.
* Beware of mixing per‑request SSR fetches inside components that you want statically generated; split responsibilities clearly.

---

## 10) Summary

* Everything you can do with `getStaticProps`, `getServerSideProps`, and `getStaticPaths` is available—and generally simpler—in the **App Router** using `fetch` with caching options and `generateStaticParams`.
* **Recommendation**: Teach and use **App Router** for new work. Keep your Pages‑Router article as a legacy reference so students can read older blog posts and still understand them.
* Hybrid rendering is first‑class in the App Router: mix SSG/ISR/SSR/CSR where each makes sense for performance, SEO, and UX.
