# **11. Creating API Endpoints in `/pages/api` (Pages Router)**

When we think of APIs in Next.js today, we usually think of the **App Router** (`app/api/.../route.js`) because that’s the new system in Next.js 13+.
But before that, APIs were built inside the **Pages Router** under the `pages/api` folder.

Even now, many companies still use this system in production because their projects were created before Next.js 13.
So, it’s important to understand **both**.

---

## **1. Where Do Pages Router APIs Live?**

In the Pages Router, all API routes are stored in the `pages/api` folder.

Example folder structure:

```
pages/
 └── api/
      └── students.js
```

The file `students.js` automatically becomes an API endpoint at:

```
/api/students
```

So if you run your app and open [http://localhost:3000/api/students](http://localhost:3000/api/students), it will execute the code inside `students.js`.

---

## **2. How API Handlers Look in Pages Router**

Unlike the App Router (which uses `export async function GET/POST/...`),
the Pages Router uses **a single default exported function** called `handler`.

This function receives two arguments:

1. **`req`** – the incoming request (like in Express.js).

   * Contains `req.method`, `req.query`, `req.body`, `req.headers`.

2. **`res`** – the response object.

   * Used to send back data with `res.status(...).json(...)` or `res.send(...)`.

---

### Example: Simple GET API in Pages Router

```javascript
// pages/api/students.js

export default function handler(req, res) {
  if (req.method === "GET") {
    const students = [
      { id: 1, name: "Jenil" },
      { id: 2, name: "Priyesha" },
    ];
    res.status(200).json(students);
  } else {
    res.status(405).json({ message: "Method not allowed" });
  }
}
```

* Visiting `/api/students` in your browser runs this code.
* If the request is a **GET**, it returns JSON with a list of students.
* Any other method (like POST or PUT) returns a `405 Method Not Allowed`.

---

## **3. Handling Multiple HTTP Methods**

In one `handler` function, we can handle different HTTP methods using `req.method`.

```javascript
// pages/api/students.js

let students = [
  { id: 1, name: "Jenil" },
  { id: 2, name: "Priyesha" },
];

export default function handler(req, res) {
  if (req.method === "GET") {
    // Read all students
    res.status(200).json(students);

  } else if (req.method === "POST") {
    // Create a new student
    const newStudent = { id: Date.now(), ...req.body };
    students.push(newStudent);
    res.status(201).json(newStudent);

  } else {
    res.status(405).json({ message: "Method not allowed" });
  }
}
```

Here:

* **GET** → returns all students.
* **POST** → accepts `req.body` (student data) and adds it.
* Any other method returns a 405.

---

## **4. Dynamic API Routes in Pages Router**

Just like App Router supports `[id]` folders,
the Pages Router supports **dynamic API routes** using `[param].js` filenames.

Example:

```
pages/api/students/[id].js
```

Inside:

```javascript
// pages/api/students/[id].js

let students = [
  { id: 1, name: "Jenil" },
  { id: 2, name: "Priyesha" },
];

export default function handler(req, res) {
  const { id } = req.query; // dynamic part from URL
  const student = students.find((s) => s.id === parseInt(id));

  if (!student) {
    return res.status(404).json({ message: "Student not found" });
  }

  if (req.method === "GET") {
    res.status(200).json(student);

  } else if (req.method === "PUT") {
    student.name = req.body.name || student.name;
    res.status(200).json(student);

  } else if (req.method === "DELETE") {
    students = students.filter((s) => s.id !== parseInt(id));
    res.status(200).json({ message: "Student deleted" });

  } else {
    res.status(405).json({ message: "Method not allowed" });
  }
}
```

Now, we can:

* **GET** `/api/students/1` → fetch Jenil.
* **PUT** `/api/students/1` → update Jenil.
* **DELETE** `/api/students/1` → remove Jenil.

---

## **5. Pages Router vs App Router APIs**

| Feature            | Pages Router (`pages/api/...`)           | App Router (`app/api/.../route.js`)                         |
| ------------------ | ---------------------------------------- | ----------------------------------------------------------- |
| File location      | `pages/api/`                             | `app/api/`                                                  |
| Handler style      | Single `export default handler(req,res)` | Export functions `GET/POST/PUT/...`                         |
| Request object     | `req.method`, `req.body`, `req.query`    | `request.method`, `await request.json()`, `request.nextUrl` |
| Response           | `res.status(200).json(...)`              | `Response.json(...)` or `NextResponse`                      |
| Dynamic routes     | `[id].js` in `pages/api`                 | `[id]/route.js` in `app/api`                                |
| Middleware support | Less integrated (custom code)            | Built-in `middleware.js` support                            |

---

## **6. Why Learn Pages Router APIs?**

Even though App Router is the future, Pages Router APIs are still:

* **Common in existing projects** → many companies haven’t migrated yet.
* **Useful for interviews** → you may be asked about both.
* **Easier to understand** if you’ve worked with Express.js or Node.js before.

---

## **Key Takeaways**

* In **Pages Router**, APIs live in `pages/api/`.
* Each file in `pages/api/` maps directly to an endpoint.
* Use a **single handler function** with `req` and `res`.
* Handle different HTTP methods using `req.method`.
* Use `[id].js` for **dynamic routes**.
* App Router simplifies things with separate `GET`, `POST`, `PUT`, `DELETE` exports.

---
