# CRUD Operations in API Routes with Next.js App Router and Mongoose

---

## 1. Introduction

CRUD is the foundation of every web application. Whether it’s:

* A **student database** at CodingGita storing enrollments,
* A **social media app** storing posts and comments,
* An **e-commerce site** managing products and orders,

…the operations are the same:

1. **Create** → Add new data.
2. **Read** → Retrieve data (all or specific).
3. **Update** → Modify existing data.
4. **Delete** → Remove unwanted data.

With the **App Router** (Next.js 13+), CRUD is even cleaner:

* Old `/pages/api/...` → replaced with `/app/api/.../route.js`.
* Each `route.js` can export `GET`, `POST`, `PUT`, `DELETE` functions.
* Fully supports **server-side code** (database queries, authentication, file handling, etc).

**Flow Diagram:**

```
Frontend (React Component)
       ↓ fetch()
Route Handler (/app/api/.../route.js)
       ↓
Mongoose (Model methods)
       ↓
MongoDB Database
```

---

## 2. Folder Structure for CRUD (App Router)

Before we start coding, let’s understand the structure.

```
/app
 └─ /api
     └─ /users
         ├─ route.js        → Handles GET (all users), POST (create user)
         └─ [id]
             └─ route.js    → Handles GET (single user), PUT (update user), DELETE (remove user)
/lib
 └─ mongodb.js              → Connection utility
/models
 └─ User.js                 → User schema and model
```

* `/app/api/users/route.js` → collection-level operations.
* `/app/api/users/[id]/route.js` → document-level operations.

This mirrors **REST API conventions**.

---

## 3. Creating Users (POST) and Fetching All Users (GET)

Let’s start with `/app/api/users/route.js`.

```javascript
import dbConnect from "@/lib/mongodb";
import User from "@/models/User";

// GET: Fetch all users
export async function GET() {
  try {
    await dbConnect();
    const users = await User.find({});
    return Response.json({ success: true, data: users }, { status: 200 });
  } catch (error) {
    return Response.json({ success: false, error: error.message }, { status: 500 });
  }
}

// POST: Create new user
export async function POST(req) {
  try {
    await dbConnect();
    const body = await req.json(); // Parse request body
    const user = await User.create(body); // Insert into DB
    return Response.json({ success: true, data: user }, { status: 201 });
  } catch (error) {
    return Response.json({ success: false, error: error.message }, { status: 400 });
  }
}
```

### How it works:

1. When the frontend calls `fetch("/api/users")` with **GET**, Mongoose runs `User.find({})`.
2. When the frontend calls `fetch("/api/users", { method: "POST" })`, we parse the request body and run `User.create()`.

---

## 4. Testing POST (Create User)

Send a request:

```bash
POST http://localhost:3000/api/users
Content-Type: application/json
```

Body:

```json
{
  "name": "Priyesha",
  "email": "priyesha@codinggita.com",
  "age": 21,
  "isStudent": true
}
```

Response:

```json
{
  "success": true,
  "data": {
    "_id": "66a9...",
    "name": "Priyesha",
    "email": "priyesha@codinggita.com",
    "age": 21,
    "isStudent": true,
    "createdAt": "2025-09-02T10:25:33.000Z",
    "updatedAt": "2025-09-02T10:25:33.000Z"
  }
}
```

---

## 5. Reading Users (GET All)

Request:

```bash
GET http://localhost:3000/api/users
```

Response:

```json
{
  "success": true,
  "data": [
    {
      "_id": "66a9...",
      "name": "Priyesha",
      "email": "priyesha@codinggita.com",
      "age": 21,
      "isStudent": true
    },
    {
      "_id": "66aa...",
      "name": "Arjun",
      "email": "arjun@codinggita.com",
      "age": 23,
      "isStudent": true
    }
  ]
}
```

---

## 6. Fetching a Single User (GET by ID)

Now for `/app/api/users/[id]/route.js`.

```javascript
import dbConnect from "@/lib/mongodb";
import User from "@/models/User";

export async function GET(req, { params }) {
  try {
    await dbConnect();
    const user = await User.findById(params.id);
    if (!user) {
      return Response.json({ success: false, message: "User not found" }, { status: 404 });
    }
    return Response.json({ success: true, data: user }, { status: 200 });
  } catch (error) {
    return Response.json({ success: false, error: error.message }, { status: 400 });
  }
}
```

Request:

```bash
GET http://localhost:3000/api/users/66a9...
```

---

## 7. Updating a User (PUT)

In the same `[id]/route.js` file:

```javascript
export async function PUT(req, { params }) {
  try {
    await dbConnect();
    const body = await req.json();

    const user = await User.findByIdAndUpdate(params.id, body, {
      new: true,           // return updated doc
      runValidators: true  // apply schema rules
    });

    if (!user) {
      return Response.json({ success: false, message: "User not found" }, { status: 404 });
    }

    return Response.json({ success: true, data: user }, { status: 200 });
  } catch (error) {
    return Response.json({ success: false, error: error.message }, { status: 400 });
  }
}
```

Request:

```bash
PUT http://localhost:3000/api/users/66a9...
Content-Type: application/json
```

Body:

```json
{
  "age": 22,
  "isStudent": false
}
```

---

## 8. Deleting a User (DELETE)

Still in `[id]/route.js`:

```javascript
export async function DELETE(req, { params }) {
  try {
    await dbConnect();
    const user = await User.findByIdAndDelete(params.id);

    if (!user) {
      return Response.json({ success: false, message: "User not found" }, { status: 404 });
    }

    return Response.json({ success: true, message: "User deleted" }, { status: 200 });
  } catch (error) {
    return Response.json({ success: false, error: error.message }, { status: 400 });
  }
}
```

Request:

```bash
DELETE http://localhost:3000/api/users/66a9...
```

Response:

```json
{ "success": true, "message": "User deleted" }
```

---

## 9. Error Handling & Validation

CRUD should never fail silently. Add checks like:

* `404 Not Found` → if `findById` returns null.
* `400 Bad Request` → invalid data (e.g., bad email format).
* `500 Internal Server Error` → unexpected errors.

Mongoose also provides **validation** at schema level, so invalid documents never get saved.

Example in `User.js`:

```javascript
email: {
  type: String,
  required: true,
  match: [/.+\@.+\..+/, "Please enter a valid email address"]
}
```

---

## 10. Testing CRUD in App Router

Use:

* **Thunder Client** (VS Code extension)
* **Postman**
* Or plain **curl**

Example:

```bash
curl -X POST http://localhost:3000/api/users \
-H "Content-Type: application/json" \
-d '{"name":"Krishna","email":"krishna@codinggita.com"}'
```

---

## 11. Best Practices with App Router CRUD

1. **Separation of concerns** → keep DB logic in models, not in components.
2. **Use Response.json()** → standard JSON responses with proper status codes.
3. **Consistent response shape**:

   ```json
   { "success": true, "data": ..., "error": ... }
   ```
4. **Middleware for auth** → protect sensitive routes.
5. **Validation everywhere** → don’t trust incoming data.

---

