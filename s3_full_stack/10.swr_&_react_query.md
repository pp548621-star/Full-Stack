# 10. Client-Side Fetching with **SWR** in Next.js 15 (App Router, JavaScript)

This article shows how to fetch client-side data using **SWR** in a modern Next.js 15 App Router project. We will use plain JavaScript and App Router conventions, and place all client-side logic inside `"use client"` components. 

---

## What SWR Is and Why It’s Useful

SWR (stale-while-revalidate) is a small React data fetching library from Vercel. Its design goal is to make client-side reads very simple and very fast:

* It returns cached data immediately (stale) and revalidates in the background to fetch the latest (while-revalidate).
* It deduplicates requests for the same key across the app.
* It supports polling, focus revalidation, pagination, and simple mutations.

Typical use cases at CodingGita:

* Student dashboards where lists (notices, assignments) refresh when the user returns to the tab.
* Read-heavy pages where you want instant cached UI, then background freshness.
* Client-only widgets embedded into an otherwise server-rendered page.

---

## Installing and Setting Up SWR

```bash
npm i swr
```

Although SWR does not require a provider, using one is helpful for global defaults.

### app/providers.js

```js
// app/providers.js
"use client";

import { SWRConfig } from "swr";

export default function Providers({ children }) {
  return (
    <SWRConfig
      value={{
        fetcher: (url) => fetch(url).then((r) => r.json()),
        revalidateOnFocus: true,
        dedupingInterval: 2000, // ms window to avoid duplicate requests
        shouldRetryOnError: true,
        errorRetryCount: 2,
      }}
    >
      {children}
    </SWRConfig>
  );
}
```

### app/layout.js

```js
// app/layout.js
import Providers from "./providers";

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
```

---

## SWR — First Example (GET): CodingGita Notices

This example lists campus notices using client-side fetching. The page renders a loading state, cached data (if any), then refreshes in the background.

### app/notices/page.js

```js
// app/notices/page.js
"use client";

import useSWR from "swr";

export default function NoticesPage() {
  const { data, error, isLoading, isValidating, mutate } = useSWR(
    "https://jsonplaceholder.typicode.com/posts"
  );

  if (isLoading) return <main className="p-6">Loading notices…</main>;
  if (error) return <main className="p-6">Failed to load notices.</main>;

  const notices = data.slice(0, 8);

  return (
    <main className="p-6">
      <div className="flex items-center justify-between mb-4">
        <h1 className="text-xl font-bold">CodingGita Notices (SWR)</h1>
        <button
          className="border px-3 py-1 rounded"
          onClick={() => mutate()} // manual revalidate now
        >
          Refresh
        </button>
      </div>

      {isValidating && <p className="text-sm text-gray-500">Updating…</p>}

      <ul className="space-y-2">
        {notices.map((n) => (
          <li key={n.id} className="border p-3 rounded">{n.title}</li>
        ))}
      </ul>
    </main>
  );
}
```

Key points:

* `useSWR(key)` triggers fetches using the global `fetcher`.
* `isLoading` is true on first mount; `isValidating` is true during background refresh.
* `mutate()` forces a revalidation.

---

## SWR — Polling and Focus Revalidation

To keep a list fresh:

* Global `revalidateOnFocus: true` refreshes data when the tab gains focus.
* Per-hook `refreshInterval` polls on an interval.

```js
const { data } = useSWR(url, { refreshInterval: 5000 }); // poll every 5s
```

Use this for soft-real-time panels (e.g., CodingGita live test scoreboard).

---

## SWR — Mutations (Create/Update) with Optimistic UI

You can optimistically update the cache, then revalidate.

### app/notices/new/page.js

```js
// app/notices/new/page.js
"use client";

import { useState } from "react";
import useSWR, { mutate } from "swr";

const LIST_KEY = "https://jsonplaceholder.typicode.com/posts";

export default function NewNoticePage() {
  const { data } = useSWR(LIST_KEY);
  const [title, setTitle] = useState("");

  async function addNotice() {
    const optimistic = { id: Date.now(), title };

    // 1) Optimistically insert at the top
    mutate(
      LIST_KEY,
      (current = []) => [optimistic, ...(current || [])],
      { revalidate: false }
    );

    // 2) Make the real request
    await fetch(LIST_KEY, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(optimistic),
    });

    // 3) Revalidate to ensure server truth
    mutate(LIST_KEY);
    setTitle("");
  }

  return (
    <main className="p-6 max-w-lg">
      <h1 className="text-xl font-bold mb-4">Add Notice (SWR)</h1>
      <div className="flex gap-2 mb-4">
        <input
          className="border p-2 rounded flex-1"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          placeholder="Notice title"
        />
        <button
          className="border px-3 py-2 rounded"
          onClick={() => title.trim() && addNotice()}
        >
          Add
        </button>
      </div>

      <pre className="bg-gray-50 p-3 rounded text-sm overflow-auto">
        {JSON.stringify((data || []).slice(0, 5), null, 2)}
      </pre>
    </main>
  );
}
```

Notes:

* `mutate(key, updater, { revalidate: false })` updates cache locally without hitting the network.
* After the server request, call `mutate(key)` to synchronize.

You can also use `useSWRMutation` (SWR v2) to separate mutations from queries. The above is simpler for beginners.

---

## SWR — Derived Keys, Filtering, and Search

Keys can include query params. SWR dedupes requests per key.

```js
const query = search.trim().toLowerCase();
const key = query
  ? `https://api.example.com/students?q=${encodeURIComponent(query)}`
  : null; // null disables fetching

const { data } = useSWR(key);
```

Debounce input to avoid excessive requests.

---

## SWR — Common Options

* `revalidateOnFocus`: refresh on tab focus.
* `refreshInterval`: polling interval.
* `dedupingInterval`: suppress duplicate requests within window.
* `keepPreviousData`: keep prior data visible while a key changes.
* `fallbackData`: provide initial data (e.g., from server) to avoid loading flashes.

---

## SWR — When To Use

* Simple, read-heavy screens where you want very low code overhead.
* Small widgets embedded in server-rendered pages.
* Straightforward mutations and polling without complex cache coordination.
* Classroom labs where students must learn the minimal viable client-side fetching.

---

## SWR — Limitations To Keep In Mind

* Complex scenarios (dependent queries, infinite lists with sophisticated caching, fine-grained invalidation across many lists) can get verbose.
* Devtools are not as comprehensive as React Query’s.
* Mutations work, but advanced workflows (optimistic updates + rollback across multiple lists) are easier in React Query.

---

## Summary (SWR)

* App Router friendly via `"use client"` components.
* Minimal API, great DX for simple GETs, polling, and optimistic inserts.
* Excellent for beginner projects and lightweight dashboards.

---


# Client-Side Fetching with **React Query** (@tanstack/react-query) in Next.js 15 (App Router, JavaScript)

React Query is a comprehensive data-synchronization library for React. It covers queries, mutations, caching, pagination, invalidation, retries, and devtools. It is well suited for **production apps** with non-trivial data flows.

---

## Installing and Provider Setup

```bash
npm i @tanstack/react-query
npm i -D @tanstack/react-query-devtools
```

### app/react-query-provider.js

```js
// app/react-query-provider.js
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { useState } from "react";

export default function ReactQueryProvider({ children }) {
  const [client] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 30_000,         // 30s fresh window
            refetchOnWindowFocus: true,
            retry: 1,                  // retry failed GETs once
          },
        },
      })
  );

  return (
    <QueryClientProvider client={client}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

### app/layout.js

```js
// app/layout.js
import ReactQueryProvider from "./react-query-provider";

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <ReactQueryProvider>{children}</ReactQueryProvider>
      </body>
    </html>
  );
}
```

(If you also use SWR, wrap both providers; order does not matter for isolated trees.)

---

## Queries (GET): CodingGita Assignments

### app/rq-assignments/page.js

```js
// app/rq-assignments/page.js
"use client";

import { useQuery } from "@tanstack/react-query";

async function fetchAssignments() {
  const res = await fetch("https://jsonplaceholder.typicode.com/todos");
  if (!res.ok) throw new Error("Failed to fetch");
  return res.json();
}

export default function AssignmentsPage() {
  const { data, isPending, isError, error } = useQuery({
    queryKey: ["assignments"],
    queryFn: fetchAssignments,
    select: (items) => items.slice(0, 10), // view-model transform in cache
  });

  if (isPending) return <main className="p-6">Loading assignments…</main>;
  if (isError) return <main className="p-6">Error: {error.message}</main>;

  return (
    <main className="p-6">
      <h1 className="text-xl font-bold mb-4">Assignments (React Query)</h1>
      <ul className="space-y-2">
        {data.map((t) => (
          <li key={t.id} className="border p-3 rounded">{t.title}</li>
        ))}
      </ul>
    </main>
  );
}
```

Key points:

* `queryKey` uniquely identifies the cached data.
* `select` safely shapes data without extra re-renders.
* Built-in `retry`, `staleTime`, `gcTime`, and focus refetch behavior.

---

## Mutations with Optimistic Updates and Rollback

This is where React Query shines. We add a new assignment, update the cache optimistically, rollback on error, then invalidate to sync.

### app/rq-assignments/manage/page.js

```js
// app/rq-assignments/manage/page.js
"use client";

import { useState } from "react";
import {
  useQuery,
  useMutation,
  useQueryClient,
} from "@tanstack/react-query";

const LIST_KEY = ["assignments"];

async function listAssignments() {
  const res = await fetch("https://jsonplaceholder.typicode.com/todos");
  if (!res.ok) throw new Error("Failed to list");
  return res.json();
}

async function createAssignment(title) {
  const res = await fetch("https://jsonplaceholder.typicode.com/todos", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ title, completed: false }),
  });
  if (!res.ok) throw new Error("Failed to create");
  return res.json();
}

export default function ManageAssignments() {
  const qc = useQueryClient();
  const [title, setTitle] = useState("");

  const { data } = useQuery({
    queryKey: LIST_KEY,
    queryFn: listAssignments,
    select: (items) => items.slice(0, 8),
  });

  const addMutation = useMutation({
    mutationFn: createAssignment,
    onMutate: async (newTitle) => {
      await qc.cancelQueries({ queryKey: LIST_KEY });
      const prev = qc.getQueryData(LIST_KEY) || [];
      const optimistic = [{ id: Date.now(), title: newTitle, completed: false }, ...prev];
      qc.setQueryData(LIST_KEY, optimistic);
      return { prev };
    },
    onError: (_err, _vars, ctx) => {
      if (ctx?.prev) qc.setQueryData(LIST_KEY, ctx.prev); // rollback
    },
    onSettled: () => {
      qc.invalidateQueries({ queryKey: LIST_KEY }); // refetch real list
    },
  });

  function add() {
    if (!title.trim()) return;
    addMutation.mutate(title);
    setTitle("");
  }

  return (
    <main className="p-6 max-w-lg">
      <h1 className="text-xl font-bold mb-4">Manage Assignments</h1>

      <div className="flex gap-2 mb-4">
        <input
          className="border p-2 rounded flex-1"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          placeholder="New assignment title"
        />
        <button className="border px-3 py-2 rounded" onClick={add}>
          Add
        </button>
      </div>

      <pre className="bg-gray-50 p-3 rounded text-sm overflow-auto">
        {JSON.stringify(data || [], null, 2)}
      </pre>
    </main>
  );
}
```

Notes:

* `onMutate` is called before the request; it updates cache optimistically and returns a context for rollback.
* `onError` restores prior cache on failure.
* `onSettled` invalidates to refetch the canonical server list.

---

## Infinite Queries (Pagination)

For large lists (e.g., “All Students”), use `useInfiniteQuery`.

### app/rq-students/page.js

```js
// app/rq-students/page.js
"use client";

import { useInfiniteQuery } from "@tanstack/react-query";

async function fetchPage({ pageParam = 1 }) {
  const res = await fetch(
    `https://jsonplaceholder.typicode.com/comments?_page=${pageParam}&_limit=10`
  );
  if (!res.ok) throw new Error("Failed to fetch page");
  const data = await res.json();
  const hasMore = data.length === 10;
  return { data, nextPage: hasMore ? pageParam + 1 : undefined };
}

export default function StudentsInfinite() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ["students"],
    queryFn: fetchPage,
    getNextPageParam: (lastPage) => lastPage.nextPage,
    initialPageParam: 1,
  });

  const items = data?.pages.flatMap((p) => p.data) || [];

  return (
    <main className="p-6">
      <h1 className="text-xl font-bold mb-4">Students (Infinite Query)</h1>
      <ul className="space-y-2">
        {items.map((c) => (
          <li key={c.id} className="border p-3 rounded">{c.email}</li>
        ))}
      </ul>

      <button
        className="mt-4 border px-3 py-2 rounded"
        disabled={!hasNextPage || isFetchingNextPage}
        onClick={() => fetchNextPage()}
      >
        {isFetchingNextPage ? "Loading…" : hasNextPage ? "Load more" : "No more"}
      </button>
    </main>
  );
}
```

---

## Performance and UX Controls

* `staleTime`: how long data stays “fresh” to avoid refetch.
* `gcTime`: cache garbage collection for inactive queries.
* `retry`: number of retries on failure.
* `refetchOnWindowFocus` / `refetchInterval`: live-updating dashboards.
* `select`: derive and memoize view-model in the cache.

---

## When To Use React Query

* Multi-page apps with several lists and detail views sharing the same entities.
* Complex mutations requiring optimistic updates and selective invalidation.
* Pagination, infinite scroll, and dependent queries.
* You want Devtools to inspect cache, timings, and states during development.

---

## SWR vs React Query — How to Choose


* If your component mostly **reads** a single endpoint, needs simple polling/focus refresh, and you want minimal code:

  * SWR is usually perfect.
* If your screen **writes** data (create/update/delete), touches multiple lists that must stay consistent, or you need pagination/infinite scroll, retries, and sophisticated caching:

  * Prefer React Query.

### Summary Table

| Criterion                  | SWR                             | React Query                                |
| -------------------------- | ------------------------------- | ------------------------------------------ |
| Learning curve             | Very small                      | Moderate                                   |
| Typical scope              | Simple GETs, small widgets      | Full apps with many lists/mutations        |
| Mutations                  | Via `mutate` / `useSWRMutation` | First-class `useMutation` with rollback    |
| Pagination/Infinite        | Manual                          | Built-in `useInfiniteQuery`                |
| Devtools                   | Limited                         | Comprehensive                              |
| Fine-grained cache control | Basic                           | Advanced (`staleTime`, `gcTime`, `select`) |

---

## Integrating with App Router

* Keep `"use client"` boundaries small. Let Server Components render static shells then mount client islands for SWR/React Query.
* For SEO-critical data, prefer **Server Components** with `fetch` (SSG/ISR/SSR). Use SWR/React Query for highly interactive or user-specific panels.
* Avoid duplicate requests by using unique, stable keys (`queryKey` in React Query, string key in SWR).

---
