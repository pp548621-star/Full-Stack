# **13. Request/Response Handling, Middlewares, and Custom Headers in Next.js APIs**

Now that we know how to perform CRUD operations in Next.js, the next step is making our APIs **production-ready**.
This means:

* Handling requests properly (reading body, query params, headers).
* Sending structured responses with status codes.
* Adding **custom headers** to responses.
* Using **middlewares** for logging, authentication, and security.


---

## **1. Understanding Requests in Next.js APIs**

When a client makes an API call, it sends along:

* **URL path** → `/api/students/2`
* **Query parameters** → `/api/students?limit=5`
* **Body data** → `{ "name": "Krishna" }`
* **Headers** → `Content-Type`, `Authorization`, etc.

### Pages Router (`req` object)

* `req.query` → query parameters
* `req.body` → JSON body
* `req.headers` → headers
* `req.method` → HTTP method

### App Router (`request` object)

* `request.url` → full URL
* `request.nextUrl.searchParams` → query params
* `await request.json()` → JSON body
* `request.headers.get("Header-Name")` → headers
* `request.method` → HTTP method

---

### Example: Reading Request Data

#### Pages Router (`pages/api/students.js`)

```javascript
// pages/api/students.js

export default function handler(req, res) {
  if (req.method === "GET") {
    const { limit } = req.query; // /api/students?limit=2

    const students = [
      { id: 1, name: "Jenil" },
      { id: 2, name: "Priyesha" },
      { id: 3, name: "Krishna" },
    ];

    const result = limit ? students.slice(0, limit) : students;

    res.status(200).json(result);
  }
}
```

#### App Router (`app/api/students/route.js`)

```javascript
// app/api/students/route.js
import { NextResponse } from "next/server";

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const limit = searchParams.get("limit"); // /api/students?limit=2

  const students = [
    { id: 1, name: "Jenil" },
    { id: 2, name: "Priyesha" },
    { id: 3, name: "Krishna" },
  ];

  const result = limit ? students.slice(0, limit) : students;

  return NextResponse.json(result, { status: 200 });
}
```

**Explanation:**

* Both examples read the query parameter `limit`.
* If present, only return that many students.
* Otherwise, return all.

---

## **2. Sending Responses**

Responses should always include:

* **Status codes** (200 OK, 201 Created, 404 Not Found, 500 Server Error).
* **Content type** (usually JSON).
* **Optional custom headers**.

### Pages Router

```javascript
res.status(201).json({ message: "Created" });
```

### App Router

```javascript
return NextResponse.json({ message: "Created" }, { status: 201 });
```

---

## **3. Custom Headers in Responses**

Custom headers let us send extra information like **rate limits, tokens, or request tracking IDs**.

#### Pages Router Example

```javascript
export default function handler(req, res) {
  res.setHeader("X-App-Name", "CodingGita API");
  res.status(200).json({ message: "Headers example" });
}
```

#### App Router Example

```javascript
import { NextResponse } from "next/server";

export async function GET() {
  return new NextResponse(
    JSON.stringify({ message: "Headers example" }),
    {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        "X-App-Name": "CodingGita API",
      },
    }
  );
}
```

**Explanation:**

* `X-App-Name` is a custom header we defined.
* Useful for debugging, API versioning, or client info.

---

## **4. Using Middleware**

Middleware lets us run code **before the API route executes**.
Typical uses:

* Authentication (check tokens).
* Logging requests.
* Blocking requests from certain IPs.

### Creating Middleware in Next.js

* File: `middleware.js` (at the root of `app/` or project).
* Runs before every request (API or page).

---

### Example: Logging Requests (middleware.js)

```javascript
// middleware.js
import { NextResponse } from "next/server";

export function middleware(request) {
  console.log("Incoming request:", request.method, request.url);

  return NextResponse.next(); // continue to API
}
```

**Explanation:**

* Every request method & URL is logged.
* `NextResponse.next()` lets it continue.

---

### Example: Protecting API Routes (middleware.js)

```javascript
// middleware.js
import { NextResponse } from "next/server";

export function middleware(request) {
  const token = request.headers.get("Authorization");

  if (request.nextUrl.pathname.startsWith("/api/students")) {
    if (token !== "mysecrettoken") {
      return NextResponse.json({ message: "Unauthorized" }, { status: 401 });
    }
  }

  return NextResponse.next();
}
```

**Explanation:**

* Any request to `/api/students` must include:
  `Authorization: mysecrettoken`
* If missing, return **401 Unauthorized**.

---

## **5. Error Handling**

When something goes wrong, always send proper status codes:

* **400 Bad Request** → Invalid input.
* **401 Unauthorized** → No or bad token.
* **404 Not Found** → Resource missing.
* **500 Internal Server Error** → Server crashed.

#### Example in App Router

```javascript
export async function GET() {
  try {
    throw new Error("Database down");
  } catch (error) {
    return NextResponse.json(
      { message: "Internal Server Error" },
      { status: 500 }
    );
  }
}
```

---

## **6. Summary Table**

| Feature        | Pages Router (`req`, `res`)              | App Router (`request`, `NextResponse`)        |
| -------------- | ---------------------------------------- | --------------------------------------------- |
| Query Params   | `req.query.limit`                        | `new URL(request.url).searchParams.get("x")`  |
| Body           | `req.body`                               | `await request.json()`                        |
| Headers        | `req.headers`                            | `request.headers.get("x")`                    |
| Response JSON  | `res.status(200).json(data)`             | `NextResponse.json(data, { status: 200 })`    |
| Custom Headers | `res.setHeader("X-App", "API")`          | `headers: { "X-App": "API" }` in NextResponse |
| Middleware     | Not built-in (write in handler manually) | Built-in `middleware.js` support              |

---

## **Key Takeaways**

* **Request handling:** use query params, body, and headers properly.
* **Responses:** always include correct status codes and messages.
* **Custom headers:** add useful metadata (like version or app name).
* **Middleware:** powerful for authentication, logging, and filtering.
* **Error handling:** send structured error responses with status codes.

---
