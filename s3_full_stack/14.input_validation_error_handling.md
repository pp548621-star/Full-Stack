Perfect â€” hereâ€™s **Article 4 of the series**, written in the same **step-by-step + runnable examples + detailed explanation style**.
This one will focus on **Input Validation and Error Handling**, which are critical for production APIs.

---

# **Input Validation and Error Handling in Next.js APIs**

Up to now, weâ€™ve built APIs that can **create, read, update, and delete** data.
But real-world APIs must also:

1. **Validate inputs** â†’ Make sure the client sends correct and safe data.
2. **Handle errors properly** â†’ Return meaningful error messages, not just crash.

Without these, APIs can become **buggy, insecure, and unreliable**.

In this article, weâ€™ll learn how to:

* Do **basic validation manually**.
* Use **libraries like Zod** for schema validation.
* Return **structured error responses**.
* Handle **unexpected server errors** safely.

---

## **1. Why Input Validation is Important**

Imagine a POST request to add a student:

```json
{ "name": "" }
```

* If we donâ€™t check, we might insert a student with no name.
* If a user sends `"age": "twenty"` instead of a number, our database might break.
* If a hacker sends `<script>alert(1)</script>`, we might be exposed to an **XSS attack**.

ðŸ‘‰ Validation ensures **data integrity** and **security**.

---

## **2. Manual Validation Example**

We can check inputs directly in code.

### Pages Router: `pages/api/students.js`

```javascript
// pages/api/students.js

let students = [];

export default function handler(req, res) {
  if (req.method === "POST") {
    const { name, age } = req.body;

    // Validation
    if (!name || typeof name !== "string") {
      return res.status(400).json({ error: "Name is required and must be a string" });
    }
    if (!age || typeof age !== "number") {
      return res.status(400).json({ error: "Age is required and must be a number" });
    }

    const newStudent = { id: Date.now(), name, age };
    students.push(newStudent);

    res.status(201).json(newStudent);
  }
}
```

**Explanation:**

* If `name` or `age` is missing/invalid â†’ return **400 Bad Request**.
* Otherwise â†’ create a new student.

---

### App Router: `app/api/students/route.js`

```javascript
// app/api/students/route.js
import { NextResponse } from "next/server";

let students = [];

export async function POST(request) {
  const body = await request.json();
  const { name, age } = body;

  if (!name || typeof name !== "string") {
    return NextResponse.json({ error: "Name is required and must be a string" }, { status: 400 });
  }
  if (!age || typeof age !== "number") {
    return NextResponse.json({ error: "Age is required and must be a number" }, { status: 400 });
  }

  const newStudent = { id: Date.now(), name, age };
  students.push(newStudent);

  return NextResponse.json(newStudent, { status: 201 });
}
```

---

## **3. Input Validation with Libraries**

Manually checking inputs works, but it becomes repetitive.
Libraries like **Zod** and **Yup** let us define **schemas** that handle validation automatically.

---

### **3.1 Using Zod**

Install Zod:

```bash
npm install zod
```

Example (App Router):

```javascript
import { NextResponse } from "next/server";
import { z } from "zod";

const studentSchema = z.object({
  name: z.string().min(1, "Name is required"),
  age: z.number().min(5, "Age must be at least 5"),
});

export async function POST(request) {
  try {
    const body = await request.json();
    const student = studentSchema.parse(body); // throws if invalid

    return NextResponse.json(student, { status: 201 });
  } catch (err) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }
}
```

ðŸ‘‰ Use `safeParse()` if you prefer not to throw errors.

---

### **3.2 Using Yup**

Install Yup:

```bash
npm install yup
```

Example (App Router):

```javascript
import { NextResponse } from "next/server";
import * as yup from "yup";

const studentSchema = yup.object({
  name: yup.string().required("Name is required"),
  age: yup.number().required("Age is required").min(5, "Age must be at least 5"),
});

export async function POST(request) {
  try {
    const body = await request.json();
    const student = await studentSchema.validate(body, { abortEarly: false });

    return NextResponse.json(student, { status: 201 });
  } catch (err) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }
}
```

ðŸ‘‰ Yup works with `await schema.validate()`. Use `abortEarly:false` to collect all errors.

---

### **Quick Comparison**

| Feature        | Zod (`zod`)                         | Yup (`yup`)                            |
| -------------- | ----------------------------------- | -------------------------------------- |
| API Style      | `schema.parse(data)` or `safeParse` | `await schema.validate(data)`          |
| Error Handling | Throws `ZodError`                   | Throws `ValidationError`               |
| TypeScript     | Great auto-inference                | Needs manual typing                    |
| Ecosystem      | Modern, TS-first                    | Mature, often used with form libraries |

---

âœ… Both Zod and Yup help avoid repetitive checks.

* Use **Zod** if you want **TypeScript-first validation**.
* Use **Yup** if your project already uses it for forms.

---

## **4. Structured Error Handling**

Good APIs donâ€™t just crash â€” they give clear, consistent error responses.

### Example Error Format

```json
{
  "error": true,
  "message": "Validation failed",
  "details": [
    { "field": "name", "message": "Name is required" },
    { "field": "age", "message": "Age must be a number" }
  ]
}
```

### Pages Router Example

```javascript
res.status(400).json({
  error: true,
  message: "Validation failed",
  details: [
    { field: "name", message: "Name is required" },
    { field: "age", message: "Age must be a number" },
  ]
});
```

---

## **5. Handling Server Errors (try/catch)**

Sometimes, errors happen in **database calls** or **file operations**.
We must catch them to avoid leaking internal details.

### App Router Example

```javascript
export async function GET() {
  try {
    // Example: database error
    throw new Error("Database connection failed");

  } catch (error) {
    console.error(error);
    return NextResponse.json(
      { error: "Something went wrong. Please try again later." },
      { status: 500 }
    );
  }
}
```

**Explanation:**

* We log the error for developers.
* We send a **safe, generic error** to the client (no stack traces).

---

## **6. Summary Table**

| Feature             | Pages Router (`pages/api/...`)                       | App Router (`app/api/.../route.js`)                         |
| ------------------- | ---------------------------------------------------- | ----------------------------------------------------------- |
| Manual Validation   | `if (!name) return res.status(400)...`               | `if (!name) return NextResponse.json(..., { status: 400 })` |
| Library Validation  | Use Zod/Yup inside handler                           | Same, but inside `async function`                           |
| Structured Errors   | `res.status(400).json({ error: true, details: [] })` | `NextResponse.json({ error: true }, { status: 400 })`       |
| Handling Exceptions | `try/catch` around code, return `500`                | `try/catch`, return `500`                                   |
| Good Practice       | Always validate body before using it                 | Always validate + catch ZodError                            |

---

## **Key Takeaways**

* **Always validate input** before saving to a database.
* **Manual validation** works but can get repetitive.
* **Zod (or Yup)** makes validation easier with schemas.
* **Return structured errors** â†’ clients can understand and fix their request.
* **Never leak internal errors** â€” catch them and send a safe `500`.

---
