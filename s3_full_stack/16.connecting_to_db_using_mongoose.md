# Connecting to the Database using Mongoose Models in a Next.js App 

---

## 1. Introduction

In the **previous article**, we set up a **MongoDB connection** inside our Next.js project using Mongoose. That gave us a reliable way to connect to the database.

But just because we can connect to MongoDB doesn’t mean our app **knows what kind of data** it should store. MongoDB by itself is **schema-less**: you can insert any document, even malformed ones:

```json
{ "name": "Mahir", "email": "mahir@codinggita.com" }
```

…and then later:

```json
{ "fullName": 123, "contact": "not-an-email" }
```

This flexibility can create problems. Imagine trying to query users by `email` when some documents don’t even have that field.

That’s where **Mongoose models** come in.

* A **Schema** defines the shape of your documents, like a **blueprint**.
* A **Model** is a JavaScript object built on top of that schema, which lets you **interact with the database** (create, read, update, delete).

Think of it this way:

* **Schema** = Rules about what a valid document should look like.
* **Model** = A factory machine that makes documents following the schema and gives you tools to query them.

With schemas and models in place, we get **data consistency**, **validation**, and **query helpers**, making our app far more reliable.

---

## 2. Understanding Mongoose Schema and Model

### What is a Schema?

A schema tells Mongoose how a document should be structured.

A schema defines:

* The **fields** a document can have.
* The **data types** of each field (`String`, `Number`, `Boolean`, `Date`, `ObjectId`).
* Any **validation rules** (e.g., email must be unique, age must be positive).
* Extra options like default values, timestamps, or indexes.

Example schema:

```javascript
const userSchema = new mongoose.Schema({
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  age: { type: Number, default: 18 },
  isStudent: { type: Boolean, default: true }
});
```

---

### What is a Model?

Once you have a schema, you compile it into a **model**.
The model gives you access to MongoDB queries, like:

* `User.create()` → Insert new users.
* `User.find()` → Get all users.
* `User.findById()` → Get a specific user.
* `User.findByIdAndUpdate()` → Update user.
* `User.findByIdAndDelete()` → Delete user.

Example model:

```javascript
const User = mongoose.model("User", userSchema);
```

Now you can do:

```javascript
await User.create({ name: "Mahir", email: "mahir@codinggita.com" });
```

---

## 3. Creating a User Model in Next.js

### Step 1: Create a Models Folder

Inside your project root, create a folder:

```
/models
```

This is where all schemas and models will live (`User.js`, `Post.js`, `Comment.js`, etc.).

---

### Step 2: Add a User Schema

Create `/models/User.js`:

```javascript
import mongoose from "mongoose";

const UserSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: [true, "Name is required"],
    },
    email: {
      type: String,
      required: [true, "Email is required"],
      unique: true, // Ensures no duplicate emails
      match: [/.+\@.+\..+/, "Please enter a valid email address"]
    },
    age: {
      type: Number,
      default: 18,
      min: [0, "Age cannot be negative"]
    },
    isStudent: {
      type: Boolean,
      default: true,
    },
  },
  { timestamps: true } // Adds createdAt and updatedAt automatically
);

// Prevent recompilation errors during hot reload in Next.js
export default mongoose.models.User || mongoose.model("User", UserSchema);
```

---

## 4. Why Use `mongoose.models` Check?

When Next.js is running in **development mode**, it hot-reloads code whenever you make changes.

If you simply wrote:

```javascript
export default mongoose.model("User", UserSchema);
```

You’d hit this error:

```
OverwriteModelError: Cannot overwrite `User` model once compiled.
```

That’s because every reload tries to create the model again.

Solution: Use:

```javascript
mongoose.models.User || mongoose.model("User", UserSchema);
```

This reuses the model if it’s already defined.

---

## 5. Using the Model in an API Route (App Router Style)

Now let’s see how to use the model inside an **App Router API Route**.

Instead of `/pages/api/users.js`, in App Router we use `/app/api/users/route.js`.

### `/app/api/users/route.js`

```javascript
import dbConnect from "@/lib/mongodb";
import User from "@/models/User";

// GET all users
export async function GET() {
  try {
    await dbConnect();
    const users = await User.find({});
    return Response.json({ success: true, data: users }, { status: 200 });
  } catch (error) {
    return Response.json({ success: false, error: error.message }, { status: 500 });
  }
}

// POST create a new user
export async function POST(req) {
  try {
    await dbConnect();
    const body = await req.json();
    const user = await User.create(body);
    return Response.json({ success: true, data: user }, { status: 201 });
  } catch (error) {
    return Response.json({ success: false, error: error.message }, { status: 400 });
  }
}
```

---

## 6. Testing the Model

Now let’s actually test it.

### Test with POST (Create a User)

Using Thunder Client, Postman, or curl:

**Request:**

```
POST http://localhost:3000/api/users
```

**Body:**

```json
{
  "name": "Priyesha",
  "email": "priyesha@codinggita.com",
  "age": 22,
  "isStudent": true
}
```

**Response:**

```json
{
  "success": true,
  "data": {
    "_id": "66ab...",
    "name": "Priyesha",
    "email": "priyesha@codinggita.com",
    "age": 22,
    "isStudent": true,
    "createdAt": "2025-09-02T08:25:33.000Z",
    "updatedAt": "2025-09-02T08:25:33.000Z",
    "__v": 0
  }
}
```

---

### Test with GET (Fetch All Users)

```
GET http://localhost:3000/api/users
```

**Response:**

```json
{
  "success": true,
  "data": [
    {
      "_id": "66ab...",
      "name": "Priyesha",
      "email": "priyesha@codinggita.com",
      "age": 22,
      "isStudent": true
    }
  ]
}
```

---

### Test with curl (Quick Terminal Test)

```bash
curl -X POST http://localhost:3000/api/users \
-H "Content-Type: application/json" \
-d '{"name":"Krishna","email":"krishna@codinggita.com"}'
```

---

## 7. Advanced Schema Features

Mongoose schemas are very powerful. Let’s see some features you’ll use often:

### 1. Default values

```javascript
age: { type: Number, default: 18 }
```

### 2. Validation

```javascript
email: { type: String, required: true, match: /.+\@.+\..+/ }
```

### 3. Indexes (for performance)

```javascript
email: { type: String, unique: true }
```

### 4. Timestamps

```javascript
{ timestamps: true }
```

Adds `createdAt` and `updatedAt`.

### 5. Custom Methods

You can define functions on schema:

```javascript
UserSchema.methods.isAdult = function () {
  return this.age >= 18;
};
```

Usage:

```javascript
const user = await User.findOne({ name: "Mahir" });
console.log(user.isAdult()); // true or false
```

---

## 8. Organizing Models in Large Projects

When your project grows:

* Create one file per model: `User.js`, `Post.js`, `Comment.js`.
* Use **PascalCase** for model names.
* Keep all models inside `/models`.
* Only import models in **server code** (API routes, server actions).
* Never import models directly into client components.

---

## 9. Common Mistakes and Fixes

1. **Using models in client components** → ❌ Not allowed, models only run server-side.
2. **Forgetting `mongoose.models` check** → Causes `OverwriteModelError`.
3. **Not connecting before queries** → Always call `await dbConnect()`.
4. **Mixing schema-less and schema-driven collections** → Keep consistent schema definitions.

---

## 10. Best Practices

* **Always validate data** at schema level.
* **Use indexes** for fields like `email` or `username`.
* **Reuse models** across routes with `mongoose.models`.
* **Centralize connection logic** in `/lib/mongodb.js`.
* **Test APIs** regularly with Postman or Thunder Client.

---