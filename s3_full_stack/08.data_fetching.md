# Understanding Data Fetching in Next.js (CSR, SSR, SSG, ISR)

One of the main strengths of Next.js is its flexibility in handling **data fetching**. Unlike plain React, which is fully client-side, Next.js gives developers multiple approaches to fetch data depending on application needs. These approaches are:

* Client-Side Rendering (CSR)
* Server-Side Rendering (SSR)
* Static Site Generation (SSG)
* Incremental Static Regeneration (ISR)

Each method solves a unique problem. To really master Next.js, you need to know not just how to implement them, but also **when to use which method in a real-world application**.

---

## 1. Client-Side Rendering (CSR)

**How it works**

* The page loads first with minimal HTML (often just a loading state).
* JavaScript runs on the client’s browser, fetches data using `fetch()` or libraries like `axios`, and then updates the UI dynamically.
* This is the same way React applications work without Next.js.

**When to use CSR**

* When SEO is not important (because content is rendered after page load).
* When the data changes frequently and you need to show real-time or user-specific content.
* Example: A social media feed (e.g., showing Arjun’s real-time notifications at CodingGita).

---

## 2. Server-Side Rendering (SSR)

**How it works**

* The data is fetched on the server **for every request**.
* Next.js uses the special function `getServerSideProps` to fetch data at request time.
* The server sends a fully rendered HTML page with the data, ensuring faster SEO-friendly pages.

**When to use SSR**

* When data changes on every request and must be fresh.
* When SEO matters (search engines will see the full content).
* Example: An online stock trading dashboard (e.g., Mahir checking current stock prices).

---

## 3. Static Site Generation (SSG)

**How it works**

* Pages are generated **at build time** (when you deploy the app).
* The HTML is created once and served to all users.
* Uses `getStaticProps` in Next.js.

**When to use SSG**

* When data does not change often.
* When you want extremely fast load times.
* Example: A blog platform (e.g., Yashvi reading Priyesha’s blog post that does not change once published).

---

## 4. Incremental Static Regeneration (ISR)

**How it works**

* A hybrid between SSG and SSR.
* Pages are statically generated at build time (like SSG).
* But you can set a **revalidation time** so that after a given interval, the static page is refreshed with the latest data in the background.
* Uses `getStaticProps` with a `revalidate` field.

**When to use ISR**

* When you need the performance of static pages but still want data to stay somewhat fresh.
* Example: An e-commerce site (e.g., Krishna viewing a product page that updates every 60 seconds with stock availability).

---

## Summary Table

| Method  | When Data is Fetched                  | SEO Friendly | Best Use Case                                 |
| ------- | ------------------------------------- | ------------ | --------------------------------------------- |
| **CSR** | In the browser after page load        | No           | Real-time feeds, dashboards                   |
| **SSR** | On every request (server)             | Yes          | Frequently changing data (e.g., stock prices) |
| **SSG** | At build time (once)                  | Yes          | Blogs, documentation                          |
| **ISR** | At build time + revalidation interval | Yes          | E-commerce, news sites                        |

---


# Data Fetching in Next.js –  `getStaticProps` 

## What is `getStaticProps`?

* `getStaticProps` is a special Next.js function that allows you to **fetch data at build time**.
* This means that Next.js will run this function **once during the build process**, fetch the required data, and generate an HTML file with that data baked in.
* When a user requests the page, Next.js serves the already pre-generated HTML, making it **very fast and SEO-friendly**.

---

## When to Use `getStaticProps`?

You should use `getStaticProps` when:

* The data **does not change often** (e.g., blog posts, product catalogs, marketing pages).
* You want **fast performance** since the content is pre-rendered.
* You care about **SEO**, as static pages are indexed better.

**Real-life Scenarios:**

1. **Blog Website** – Articles that don’t change once published.
2. **E-commerce Product Listing** – Product descriptions and categories that rarely change.
3. **Documentation Pages** – Technical documentation that updates only during new releases.

---

## Example: Fetching Posts with `getStaticProps`

We’ll use the **JSONPlaceholder API** (`https://jsonplaceholder.typicode.com/posts`) to simulate a blog scenario.

### Step 1: Create a New Page

Inside your `pages/` folder, create a file called `posts.js`.

```javascript
// pages/posts.js
import React from "react";

// This function runs at build time
export async function getStaticProps() {
  // Fetching posts from JSONPlaceholder API
  const res = await fetch("https://jsonplaceholder.typicode.com/posts");
  const posts = await res.json();

  return {
    props: {
      posts, // Passed as props to the page
    },
  };
}

export default function Posts({ posts }) {
  return (
    <div style={{ padding: "20px", fontFamily: "Arial" }}>
      <h1>Blog Posts (SSG using getStaticProps)</h1>
      <ul>
        {posts.slice(0, 10).map((post) => (
          <li key={post.id}>
            <h2>{post.title}</h2>
            <p>{post.body}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

## How This Works

1. **Build Time Execution**:

   * When you run `npm run build`, Next.js will execute the `getStaticProps` function.
   * It will fetch data from JSONPlaceholder and generate static HTML pages for `/posts`.

2. **Props Injection**:

   * The fetched data (`posts`) is passed as props into the `Posts` component.

3. **Fast Performance**:

   * When users visit `/posts`, the page is served instantly from pre-built static files.

---

## Advantages of `getStaticProps`

1. **Performance** – Pages load almost instantly.
2. **SEO** – Search engines can easily crawl static content.
3. **Scalability** – Once built, the same static file can be served to thousands of users.

---

## Limitations of `getStaticProps`

1. **Data Freshness** – Since the data is fetched at build time, it can become outdated if the API changes frequently.
2. **Build Time Cost** – If you have thousands of pages, build times can increase significantly.

---

## Visual Flow

1. Build starts → Next.js calls `getStaticProps`.
2. Data is fetched → HTML generated.
3. User requests page → Static HTML served instantly.

---

# Server-Side Rendering (SSR) with `getServerSideProps` in Next.js

In the previous part, we explored **Static Site Generation (SSG)** using `getStaticProps` and understood how it is useful for pre-rendering data at build time. However, not all applications can rely on data that is generated once during the build. Many real-world apps require **fresh data every time a user visits the page**. This is where **Server-Side Rendering (SSR)** comes into play.

---

## What is SSR in Next.js?

* **Server-Side Rendering (SSR)** means the HTML of the page is generated **on each request**.
* This ensures that the user always sees the **most up-to-date content**.
* Next.js achieves SSR through the function `getServerSideProps`.
* Unlike `getStaticProps` (which runs only at build time), `getServerSideProps` runs **every time a request is made to the page**.

---

## Syntax of `getServerSideProps`

```javascript
export async function getServerSideProps(context) {
  // Fetch data here
  return {
    props: {
      // Pass data as props to the page
    },
  }
}
```

* The `context` parameter provides useful information about the request such as query parameters, cookies, or headers.
* The returned object **must contain `props`**, which is passed to the React component.

---

## Real-Life Example with JSONPlaceholder

Let’s say we want to display a list of posts for a **news feed** page, where the latest posts must be shown every time a user visits. Since the content changes frequently, using SSR is a good choice.

### Code Example

```javascript
// pages/ssr-posts.js

import React from "react";

export default function SSRPosts({ posts }) {
  return (
    <div style={{ padding: "20px" }}>
      <h1>Latest Posts (SSR Example)</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id} style={{ marginBottom: "10px" }}>
            <strong>{post.title}</strong>
            <p>{post.body}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}

// Server-Side Rendering with getServerSideProps
export async function getServerSideProps() {
  const res = await fetch("https://jsonplaceholder.typicode.com/posts");
  const posts = await res.json();

  return {
    props: {
      posts: posts.slice(0, 5), // Display only first 5 posts
    },
  };
}
```

---

## How This Works

1. When a user requests `/ssr-posts`, Next.js sends a request to the server.
2. The server runs `getServerSideProps` to fetch the latest posts from JSONPlaceholder.
3. The fetched data is passed to the `SSRPosts` component as props.
4. The page is rendered with the **fresh data** and sent to the browser.

---

## When Should You Use SSR?

Use SSR (`getServerSideProps`) in scenarios like:

* **News websites** where content changes every minute.
* **Stock market dashboards** showing live data.
* **Personalized user pages** (e.g., dashboards that depend on logged-in user details).
* **Weather apps** where data must always be up to date.

Example:
At CodingGita, if we are building a **student dashboard** where each student logs in and sees their **personal marks, assignments, and notifications**, we would use SSR. This ensures the data is always fresh and personalized.

---

## Pros and Cons of SSR

### Pros

* Always shows **fresh data**.
* Great for **SEO** since the server returns a complete HTML page with updated content.
* Can handle **personalized content per user request**.

### Cons

* **Slower than SSG**, since the server must fetch data on every request.
* Increased **server load** for high-traffic sites.
* More **expensive** in terms of resources compared to static rendering.

---

## Key Difference Between SSG and SSR

| Feature      | SSG (`getStaticProps`)  | SSR (`getServerSideProps`) |
| ------------ | ----------------------- | -------------------------- |
| Data fetched | At build time           | On every request           |
| Performance  | Very fast (cached HTML) | Slower (fetch on request)  |
| Use case     | Rarely changing data    | Frequently changing data   |

---

# Incremental Static Regeneration (ISR)

## 1. What is ISR?

**ISR (Incremental Static Regeneration)** is a feature of Next.js that allows you to **update static pages after the build time**, without rebuilding the entire app.

It’s like a **hybrid approach** between **SSG (fast static pages)** and **SSR (always fresh pages)**.

* With **SSG**, the page is generated **once at build time** and then served to every request. The content becomes **stale** if the underlying data changes.
* With **ISR**, you can tell Next.js to **regenerate the page after a certain interval** (`revalidate`), so users see **fresh data automatically**—without needing a full rebuild.

This is especially useful for websites with **dynamic content that changes periodically** (but not on every request), such as:

* Blogs (new posts added once in a while)
* News sites (articles update every few minutes)
* E-commerce stores (product prices and stock updated daily or hourly)

---

## 2. How ISR Works

1. The first user request generates the **static HTML page** (same as SSG).
2. Next.js stores this page in the **cache**.
3. After the `revalidate` time has passed, the **next request** will trigger a **background regeneration** of the page.
4. Users still see the cached page until the new one is built.
5. Once regeneration is complete, future requests get the **freshly updated page**.

This ensures:

* **Speed** (users get cached static pages instantly)
* **Freshness** (new data appears automatically after revalidation)

---

## 3. ISR Syntax in Next.js

ISR is implemented inside `getStaticProps` using the **`revalidate`** property.

```javascript
export async function getStaticProps() {
  const res = await fetch("https://jsonplaceholder.typicode.com/posts");
  const posts = await res.json();

  return {
    props: {
      posts,
    },
    // Page will re-generate at most once every 10 seconds
    revalidate: 10,
  };
}
```

Here:

* The page is **pre-rendered at build time**.
* After **10 seconds**, the next user request will **trigger a regeneration** in the background.
* Subsequent requests will get the **new updated page**.

---

## 4. Full ISR Example

Let’s build a **blog page** that regenerates every 30 seconds.

**`pages/blogs.js`**

```javascript
import React from "react";

export default function Blogs({ posts, time }) {
  return (
    <div style={{ fontFamily: "sans-serif", padding: "20px" }}>
      <h1>Blog List (ISR Example)</h1>
      <p>Page generated at: {time}</p>
      <ul>
        {posts.slice(0, 5).map((post) => (
          <li key={post.id}>
            <strong>{post.title}</strong>
          </li>
        ))}
      </ul>
      <p>
        (This page will revalidate every <strong>30 seconds</strong>)
      </p>
    </div>
  );
}

export async function getStaticProps() {
  const res = await fetch("https://jsonplaceholder.typicode.com/posts");
  const posts = await res.json();

  return {
    props: {
      posts,
      time: new Date().toLocaleTimeString(),
    },
    revalidate: 30, // ISR interval
  };
}
```

---

## 5. Key Points About ISR

* **`revalidate` value is in seconds.**

  * `revalidate: 60` → regenerate once every 1 minute.
  * `revalidate: 86400` → regenerate once every day.

* **Regeneration is background process.**

  * Users won’t wait for regeneration; they get the cached page instantly.
  * Next request after regeneration serves the updated page.

* **Works only with `getStaticProps`.**

  * Not available with `getServerSideProps` or CSR.

* **Best use case:**

  * Content that changes **periodically**, not every request.

---

## 6. Real-Life Example Use Cases

* **News Portal:** Headlines updated every 60 seconds (`revalidate: 60`).
* **E-commerce Store:** Prices updated every 1 hour (`revalidate: 3600`).
* **University Website:** Admission stats updated once daily (`revalidate: 86400`).
* **Blog/Articles:** Revalidate every 5 minutes to fetch new posts.

---

## 7. ISR vs SSG vs SSR vs CSR

| Rendering Method | When Generated                        | Data Freshness            | Performance                | Best For                    |
| ---------------- | ------------------------------------- | ------------------------- | -------------------------- | --------------------------- |
| **SSG**          | At build time                         | Stale if data changes     | Very fast                  | Content that rarely changes |
| **ISR**          | At build time + periodic regeneration | Fresh (based on interval) | Fast (cached)              | Blogs, news, e-commerce     |
| **SSR**          | On every request                      | Always fresh              | Slower (server processing) | Dashboards, live data       |
| **CSR**          | On client-side                        | Always fresh (from API)   | Depends on client fetch    | SPAs, user dashboards       |

---

## 8. Summary

* ISR is **Static + Automatic Regeneration**.
* Combines **speed of SSG** with **freshness of SSR**.
* Controlled with the **`revalidate`** property inside `getStaticProps`.
* Ideal for content that updates periodically (blogs, news, product pages).

---

# Client-Side Rendering (CSR) with `useEffect` in Next.js

## 1. Introduction

In modern web development, **rendering strategies** play a crucial role in determining **how and when content is shown to the user**.
So far, we’ve discussed:

* **SSR (Server-Side Rendering)** → Fetching data on the server for every request.
* **SSG (Static Site Generation)** → Pre-building pages at build time.
* **ISR (Incremental Static Regeneration)** → Regenerating static pages in the background.

Now, we move to **Client-Side Rendering (CSR)**. CSR is different because **the page is rendered without pre-fetched data**. Instead, data is fetched **in the browser** after the page loads.

This approach is commonly used when:

* Data is **personalized per user** (e.g., a dashboard).
* Data changes **frequently in real-time** (e.g., stock prices).
* SEO is **not a priority** (e.g., logged-in areas of an app).

---

## 2. What is CSR?

**Client-Side Rendering (CSR)** means that the **initial HTML page is almost empty** (except for JavaScript code).
When the browser loads the page:

1. React is loaded.
2. A request (via `fetch`, `axios`, or similar) is sent to an API.
3. The response data is injected into the React component.
4. The UI updates dynamically in the browser.

So instead of the **server preparing the full page**, the **browser does the work**.

---

## 3. CSR Workflow in Next.js

Here’s the step-by-step workflow:

1. User requests a page (`/products`).
2. The server returns **only the React shell** (basic HTML + JS).
3. The React component runs in the browser.
4. Inside `useEffect`, an API call is made (`fetch`/`axios`).
5. The response data updates the component state.
6. The UI re-renders with fetched data.

This is **React’s traditional SPA behavior** but inside Next.js.

---

## 4. Why use CSR?

### Advantages:

* **Dynamic data** → Always up-to-date since fetching happens on every visit.
* **User-specific content** → Each user sees their own data (like dashboards).
* **Reduced server load** → The server doesn’t need to render HTML repeatedly.

### Disadvantages:

* **SEO issues** → Search engines may not index the content well (since data loads later).
* **Slower initial load** → User sees a blank/loading state before data appears.
* **More API calls** → Each user triggers an API call from their browser.

---

## 5. Example: CSR in Next.js using `useEffect`

Let’s implement a **basic CSR example** that fetches posts from a public API.

```jsx
"use client"; // Required in Next.js 13+ App Router for client components

import { useEffect, useState } from "react";

export default function PostsPage() {
  // Step 1: State to store posts and loading state
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);

  // Step 2: Fetch data after component mounts
  useEffect(() => {
    async function fetchPosts() {
      try {
        const res = await fetch("https://jsonplaceholder.typicode.com/posts");
        const data = await res.json();
        setPosts(data); // Update state with posts
      } catch (error) {
        console.error("Error fetching posts:", error);
      } finally {
        setLoading(false); // Stop loading
      }
    }
    fetchPosts();
  }, []);

  // Step 3: Render UI
  return (
    <main className="p-6 max-w-2xl mx-auto">
      <h1 className="text-2xl font-bold mb-4">Blog Posts (CSR Example)</h1>

      {/* Show loader while fetching */}
      {loading && <p className="text-gray-500">Loading posts...</p>}

      {/* Render posts */}
      <ul className="space-y-4">
        {posts.map((post) => (
          <li
            key={post.id}
            className="p-4 border rounded-lg shadow hover:shadow-md transition"
          >
            <h2 className="font-semibold">{post.title}</h2>
            <p className="text-gray-600 text-sm">{post.body}</p>
          </li>
        ))}
      </ul>
    </main>
  );
}
```

---

## 6. Explanation of the Example

* **`useState`** → Stores posts and loading status.
* **`useEffect`** → Runs only after the component is mounted. Perfect for API calls.
* **`fetch()`** → Makes a GET request to the JSONPlaceholder API.
* **`loading`** → Ensures the user sees a “Loading...” message until data arrives.
* **Final render** → Displays all posts in a styled list.

---

## 7. Where to use CSR?

CSR is best suited for:

* **Dashboards** (user-specific data).
* **Real-time applications** (chat apps, stock trackers).
* **Authenticated pages** (where SEO doesn’t matter).
* **Client-only features** (that require user interactions like filters, forms).

---

## 8. CSR vs SSR vs SSG vs ISR

| Rendering Strategy | When Data is Fetched        | Best For                                    | SEO Friendly? |
| ------------------ | --------------------------- | ------------------------------------------- | ------------- |
| **SSR**            | On every request (server)   | Fresh content, SEO pages                    | Yes           |
| **SSG**            | At build time               | Static blogs, marketing pages               | Yes           |
| **ISR**            | After build (on demand)     | Semi-static data with updates               | Yes           |
| **CSR**            | In the browser (after load) | Dashboards, logged-in pages, real-time apps | No            |

---

## 9. Key Takeaways

* CSR renders data **on the client after load** using hooks like `useEffect`.
* It is **not SEO-friendly**, so avoid it for public-facing content.
* Great for **user dashboards, authenticated content, and real-time apps**.
* Next.js makes CSR seamless since it’s just **React running inside Next.js**.

---

# Hybrid Rendering in Next.js

## 1. Introduction

Next.js is a powerful React framework because it allows developers to **choose the right rendering strategy** for each page. Some pages may need **Static Site Generation (SSG)**, others may benefit from **Server-Side Rendering (SSR)**, and yet others from **Client-Side Rendering (CSR)**. But what if your application has **mixed requirements**?

That’s where **Hybrid Rendering** comes in. Next.js supports a **hybrid approach**, meaning different pages—or even different parts of the same page—can use different rendering strategies. This flexibility makes Next.js stand out from frameworks that force a single rendering method.

---

## 2. What is Hybrid Rendering?

**Hybrid Rendering** in Next.js means combining multiple rendering strategies in the same application.

For example:

* Your homepage could use **SSG** because it doesn’t change often.
* Your product detail pages could use **ISR (Incremental Static Regeneration)** to revalidate data periodically.
* Your admin dashboard could use **SSR** to ensure real-time accuracy.
* A search results component could use **CSR** because it fetches data based on user input after the page loads.

This mix-and-match approach allows you to optimize for **performance, SEO, and user experience** simultaneously.

---

## 3. Why Do We Need Hybrid Rendering?

Modern applications often deal with **different types of data**:

* **Static data**: Content that rarely changes (e.g., "About Us" page).
* **Semi-static data**: Content that updates periodically (e.g., product catalog, blog posts).
* **Dynamic data**: Content that changes frequently or per user (e.g., dashboards, notifications).
* **User-triggered data**: Content fetched after an action (e.g., search results, filters).

No single rendering strategy can handle all of these optimally. **Hybrid rendering ensures each page or component is rendered in the most efficient way.**

---

## 4. How Hybrid Rendering Works in Next.js

Next.js allows you to:

1. **Choose rendering per page**

   * Using `getStaticProps` (SSG), `getServerSideProps` (SSR), or CSR with `useEffect`.
2. **Mix rendering inside a single page**

   * Example: Static content for SEO + dynamic widgets fetched with CSR.

---

## 5. Example: Hybrid Rendering in Practice

Imagine you are building a **product page** for an e-commerce site.

* **Static parts (SSG/ISR):** Product title, description, and images (don’t change frequently).
* **Dynamic parts (SSR):** Stock availability (must be accurate when user loads the page).
* **Client-side parts (CSR):** Customer reviews (fetched after page load for performance).

### Code Example: Hybrid Rendering in a Product Page

```jsx
// pages/product/[id].js
import { useEffect, useState } from "react";

export default function ProductPage({ product }) {
  const [reviews, setReviews] = useState([]);

  // CSR: Fetch reviews after page load
  useEffect(() => {
    fetch(`https://fakestoreapi.com/products/${product.id}/reviews`)
      .then((res) => res.json())
      .then((data) => setReviews(data));
  }, [product.id]);

  return (
    <div style={{ padding: "20px" }}>
      {/* SSG/ISR Section */}
      <h1>{product.title}</h1>
      <p>{product.description}</p>
      <img src={product.image} alt={product.title} width="200" />

      {/* SSR Section */}
      <h3>Stock: {product.stock > 0 ? "Available" : "Out of Stock"}</h3>

      {/* CSR Section */}
      <h3>Customer Reviews</h3>
      {reviews.length > 0 ? (
        reviews.map((r, index) => <p key={index}>{r.comment}</p>)
      ) : (
        <p>Loading reviews...</p>
      )}
    </div>
  );
}

// ISR for product details
export async function getStaticProps({ params }) {
  const res = await fetch(`https://fakestoreapi.com/products/${params.id}`);
  const product = await res.json();

  return {
    props: {
      product,
    },
    revalidate: 60, // ISR: Regenerate every 60 seconds
  };
}

export async function getStaticPaths() {
  const res = await fetch("https://fakestoreapi.com/products");
  const products = await res.json();

  const paths = products.map((p) => ({
    params: { id: p.id.toString() },
  }));

  return { paths, fallback: "blocking" };
}
```

---

## 6. Breakdown of the Example

* **SSG with ISR**:

  * The product details are generated at build time.
  * With ISR, the page regenerates every 60 seconds.

* **SSR (Simulated in Stock)**:

  * If stock availability were fetched dynamically in `getServerSideProps`, it would always be accurate.
  * For this example, stock is included in SSG props, but in real-world apps, SSR would be better.

* **CSR for Reviews**:

  * Reviews are fetched after the page loads.
  * This reduces the load on the server and improves performance.

---

## 7. Benefits of Hybrid Rendering

* **Performance Optimization**

  * Static pages load instantly.
  * Only dynamic parts are rendered on-demand.

* **SEO-Friendly**

  * Critical content (title, description) is pre-rendered for crawlers.

* **Scalability**

  * Popular pages can be statically served.
  * Rarely accessed pages can use SSR.

* **Flexibility**

  * Developers can pick the best strategy for each use case.

---

## 8. When to Use Hybrid Rendering

* E-commerce sites (product catalog + stock updates + user reviews).
* News sites (static articles + real-time trending section).
* SaaS dashboards (static info + live user-specific analytics).
* Learning platforms (static course pages + dynamic student progress).

---

## 9. Conclusion

Hybrid Rendering in Next.js is about **choosing the right tool for the job**. Instead of being locked into SSR or SSG for the entire app, you can decide page by page, and even section by section.

This flexibility is what makes Next.js ideal for **large-scale production apps** like e-commerce platforms, SaaS dashboards, and content-heavy websites.

In the next article, we’ll move deeper into **Server Components in Next.js (App Router)**, which take hybrid rendering even further by blending **server-side React rendering with client interactivity.**

---

