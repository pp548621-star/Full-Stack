# Setting up MongoDB and Mongoose in a Next.js App

## 1. Why Do We Need a Database in Next.js?

When you build applications with **Next.js**, you are often dealing with **data**. For example:

* A blog needs to store posts and comments.
* An e-commerce app needs to store products, users, and orders.
* A learning platform (like CodingGita) needs to store courses, students, and submissions.

If this data is temporary (like form state or search filters), React’s `useState` is enough.
But if data should **persist across users and sessions**, we need a **database**.

---

## 2. SQL vs NoSQL – Why MongoDB?

There are two main types of databases:

* **SQL (Relational Databases)** → Structured, table-based (MySQL, PostgreSQL).
* **NoSQL (Non-Relational Databases)** → Document-based, flexible (MongoDB, DynamoDB).

**MongoDB**:

* Stores data as **JSON-like documents**.
* Works seamlessly with JavaScript/Next.js since both use JSON.
* Very flexible → You don’t have to predefine rigid schemas.
* Scales horizontally → Perfect for modern apps.

Example of a MongoDB document (User):

```json
{
  "name": "Mahir Patel",
  "email": "mahir@codinggita.com",
  "age": 21,
  "isStudent": true
}
```

---

## 3. What is Mongoose and Why Use It?

While MongoDB allows you to insert documents without structure, that’s not always good.
Imagine accidentally saving:

```json
{ "name": 123, "email": "not-an-email" }
```

That’s where **Mongoose** comes in:

* It enforces **schemas** (rules for your data).
* Provides **validation** (e.g., email must be a string).
* Gives you **query helpers** like `.find()`, `.save()`, `.populate()`.

So:

* MongoDB = Warehouse (stores boxes/documents).
* Mongoose = Warehouse Manager (ensures boxes are labeled properly and organized).

---

## 4. How Next.js and MongoDB Work Together

Next.js has two parts:

1. **Frontend (React pages/components)** → Runs in the browser.
2. **Backend (API routes, server functions)** → Runs on the server.

❌ You should **never connect directly to MongoDB from the frontend** (security risk).
✅ Instead, frontend → API Route → Mongoose → MongoDB.

**Flow Diagram:**

```
User Browser → Next.js Page → API Route (/api/…) → dbConnect() → MongoDB
```

---

## 5. Setting Up MongoDB

You have two options:

### Option A: Local MongoDB

1. Install MongoDB from [mongodb.com/try/download](https://www.mongodb.com/try/download).
2. Run it:

   ```bash
   mongod
   ```
3. Connect using `mongodb://localhost:27017/myDatabase`.

### Option B: MongoDB Atlas (Recommended)

1. Go to [https://www.mongodb.com/atlas](https://www.mongodb.com/atlas).
2. Create a free cluster.
3. Add your **IP to whitelist** (0.0.0.0/0 allows all, but not secure).
4. Create a database user.
5. Copy the connection string, e.g.:

   ```
   mongodb+srv://username:password@cluster0.mongodb.net/myDatabase
   ```

---

## 6. Installing Mongoose in Next.js

Inside your Next.js project:

```bash
npm install mongoose
```

---

## 7. Environment Variables

Create a file `.env.local` in your project root:

```env
MONGODB_URI=mongodb+srv://<username>:<password>@cluster0.mongodb.net/myDatabase
```

> Note: `.env.local` is ignored by Git, so your credentials are safe.

You’ll access it in Next.js using:

```javascript
process.env.MONGODB_URI
```

---

## 8. Creating a Database Utility

We need a **reusable function** to connect to MongoDB.
Problem: Next.js **hot reloads** during development and may create **multiple DB connections**.
Solution: Use a **global cache**.

Create: `/lib/mongodb.js`

```javascript
import mongoose from "mongoose";

const MONGODB_URI = process.env.MONGODB_URI;

if (!MONGODB_URI) {
  throw new Error("Please define the MONGODB_URI environment variable inside .env.local");
}

// Global is used here to maintain a cached connection across hot reloads
let cached = global.mongoose;

if (!cached) {
  cached = global.mongoose = { conn: null, promise: null };
}

async function dbConnect() {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    cached.promise = mongoose.connect(MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    }).then((mongoose) => mongoose);
  }

  cached.conn = await cached.promise;
  return cached.conn;
}

export default dbConnect;
```

---

## 9. Testing the Connection

Let’s create a test API route: `/pages/api/test.js`

```javascript
import dbConnect from "../../lib/mongodb";

export default async function handler(req, res) {
  try {
    await dbConnect();
    res.status(200).json({ message: "Connected to MongoDB successfully!" });
  } catch (error) {
    res.status(500).json({ message: "Connection failed", error: error.message });
  }
}
```

Now run:

```bash
npm run dev
```

Visit: [http://localhost:3000/api/test](http://localhost:3000/api/test)

Expected output:

```json
{ "message": "Connected to MongoDB successfully!" }
```

---

## 10. Common Errors and Fixes

* **Error: IP not allowed** → Fix by adding your IP in MongoDB Atlas Network Access.
* **Error: bad auth** → Check username/password.
* **Error: ECONNREFUSED** → MongoDB not running locally.
* **Too many connections** → Ensure you use the **cached connection** method.

---

## 11. Best Practices

* Always keep your MongoDB URI in `.env.local`.
* Use **Atlas for production**, local MongoDB for dev.
* Monitor DB performance with MongoDB Compass or Atlas Dashboard.
* Don’t connect inside React components (only API routes / server functions).

---

