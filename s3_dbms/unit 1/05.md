# Database Architecture (1-Tier, 2-Tier, 3-Tier)

## 1. Introduction

A **Database Architecture** defines the **structure of interactions** between users, applications, and the database.
It tells us **where the DBMS is installed**, **how users access it**, and **how requests are processed**.

Different architectures are suited for different scenarios:

* A single student testing SQL on their laptop → **1-Tier**.
* A teacher accessing CodingGita’s Student DB via an application → **2-Tier**.
* A full web application (like CodingGita portal with frontend, backend, and DB) → **3-Tier**.

---

## 2. 1-Tier Architecture (Standalone)

### Definition

* The **simplest form** of database architecture.
* The DBMS and the user/application run on the **same machine**.
* User interacts directly with the database.

### Example – CodingGita Student

* Mahir installs **MySQL Workbench** on his laptop.
* He writes and executes queries directly:

  ```sql
  SELECT * FROM Student;
  ```
* Both **application (SQL interface)** and **database** are on the same system.

### Diagram (Textual)

```
[ User (Mahir) ]
        |
[ DBMS + Database on same machine ]
```

### Advantages

* Simple and fast (no network delay).
* Best for learning and development.

### Disadvantages

* Not scalable for multiple users.
* No security (anyone with access can query).
* Cannot handle enterprise-level loads.

---

## 3. 2-Tier Architecture (Client-Server)

### Definition

* The application is divided into **Client** and **Server**.
* The **Client** (front-end app) directly communicates with the **Database Server**.
* Used in small organizations or applications.

### Example – CodingGita Faculty System

* A teacher opens a **desktop application** to view marks.
* The application sends SQL queries directly to the **Database Server**.
* Example Query:

  ```sql
  SELECT Name, Marks FROM Student WHERE CourseID = 'DBMS101';
  ```

### Diagram (Textual)

```
[ Client Application (Faculty Desktop App) ]
                |
                v
[ Database Server (MySQL / Oracle) ]
```

### Advantages

* Faster than 3-tier (direct DB connection).
* Easy to implement for small-scale systems.

### Disadvantages

* Scalability issues (too many clients overload the DB).
* Business logic is mixed with database logic → less secure.
* Maintenance is harder if app grows.

---

## 4. 3-Tier Architecture (Most Common)

### Definition

* Divides the system into **three layers**:

  1. **Presentation Layer (Client – UI)**
  2. **Application Layer (Server – Business Logic)**
  3. **Database Layer (DBMS + Data)**

* Users never directly interact with the database.

* Requests go through the **Application Server** first.

### Example – CodingGita Student Portal

* **Frontend (Presentation):** Website or Mobile App (React/Angular).
* **Backend (Application Server):** Express.js/Node.js API.
* **Database (DB Layer):** MySQL / MongoDB.

Flow:

1. Student logs in through the web app.
2. Request goes to the **Node.js Server**.
3. Server checks authentication → queries DB → sends back results.

### Diagram (Textual)

```
[ Presentation Layer (Browser / App) ]
                |
                v
[ Application Layer (Server – Node/Java/PHP) ]
                |
                v
[ Database Layer (MySQL / MongoDB) ]
```

### Advantages

* Highly scalable (millions of users).
* Strong security (DB hidden behind application layer).
* Separation of concerns (UI, business logic, data).
* Easy to maintain and extend.

### Disadvantages

* Slower than 2-tier (extra layer).
* More complex to design and maintain.

---

## 5. Real-Life Analogies

* **1-Tier:** Like writing notes directly in your own notebook. (Personal use only.)
* **2-Tier:** Like a student asking the librarian directly for a book. (Direct request, but librarian may get overloaded.)
* **3-Tier:** Like a student ordering a book via the library website → the librarian (backend) checks → the book database confirms. (Organized, scalable, secure.)

---

## 6. Where Each Architecture is Used

* **1-Tier:** Learning SQL, personal projects, testing environments.
* **2-Tier:** Small office applications, early desktop apps (bank teller systems).
* **3-Tier:** Web apps, enterprise portals, e-commerce, banking apps, CodingGita student portal.

---

## 7. Summary

* **1-Tier Architecture:** DBMS and user are on the same machine. (Best for learning, not scalable.)
* **2-Tier Architecture:** Client talks directly to DB server. (Simple, but limited scalability.)
* **3-Tier Architecture:** Adds an application server layer between client and DB. (Most secure, scalable, widely used.)
* CodingGita → uses **3-Tier architecture** for its portal (Frontend in React, Backend in Node.js, DB in MySQL/MongoDB).

---
