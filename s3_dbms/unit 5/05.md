# Deadlock Handling

## 1. What is a Deadlock?

A **deadlock** occurs when two or more transactions:

1. Compete for resources.
2. Each holds a lock on one resource.
3. Each waits for the other to release another lock.
4. Result â†’ **infinite waiting loop**.

ðŸ‘‰ In **CodingGita Portal**:

* Faculty A updates **Marks** of a student and then wants to change **City**.
* Faculty B updates **City** of the same student and then wants to change **Marks**.
* Neither releases its lock â†’ both are stuck forever.

---

## 2. Deadlock Example â€“ CodingGita Student DB

**Transaction T1 (Faculty A):**

```sql
LOCK-X(Marks);  
UPDATE Enrollment SET Marks = 92 WHERE RollNo = 101;  
-- Now needs City
```

**Transaction T2 (Faculty B):**

```sql
LOCK-X(City);  
UPDATE Student SET City = 'Rajkot' WHERE RollNo = 101;  
-- Now needs Marks
```

**Wait-for Graph**

```
T1 â†’ T2  
T2 â†’ T1  
(Cycle detected â†’ Deadlock!)
```

ðŸ‘‰ This cycle means **neither T1 nor T2 can proceed**.

---

## 3. Conditions for Deadlock (Coffmanâ€™s Conditions)

For deadlock to happen, **all four must hold true**:

1. **Mutual Exclusion** â†’ Resource locked by only one transaction.
2. **Hold and Wait** â†’ Transaction holds one resource and waits for another.
3. **No Preemption** â†’ Locks canâ€™t be forcibly taken away.
4. **Circular Wait** â†’ Transactions form a cycle waiting for each other.

---

## 4. Deadlock Handling Techniques

### 4.1 Deadlock Prevention

Break at least one Coffman condition.

#### (a) Timeout

* A transaction waits only for a fixed time, then aborts.
* Simple but may abort unnecessarily.

ðŸ‘‰ Example: If Faculty A doesnâ€™t get City lock in **10 seconds**, transaction is rolled back and restarted.

#### (b) Wait-Die Scheme (non-preemptive)

* Priority = based on **timestamp** (older transactions are more important).
* If older wants resource â†’ it waits.
* If younger wants resource held by older â†’ it dies (aborts and restarts later).

ðŸ‘‰ Example:

* T1 (older), T2 (younger).
* T2 requests Marks (held by T1) â†’ T2 dies and restarts.

#### (c) Wound-Wait Scheme (preemptive)

* Also uses timestamps.
* If older requests â†’ younger is wounded (aborted).
* If younger requests â†’ it waits.

ðŸ‘‰ Example:

* T1 (older) wants City held by T2 (younger).
* T2 is killed, T1 proceeds safely.

---

### 4.2 Deadlock Detection

* Allow deadlocks, then **detect using Wait-for Graphs**.
* Build graph: nodes = transactions, edges = waiting.
* If cycle exists â†’ deadlock.

ðŸ‘‰ Example:

```
T1 â†’ T2  
T2 â†’ T3  
T3 â†’ T1  
(Cycle detected â†’ Deadlock exists)
```

---

### 4.3 Deadlock Recovery

Once detected, system must break it. Options:

1. **Transaction Rollback**

   * Abort one or more transactions.
   * Undo their changes (using log).

2. **Victim Selection**

   * Pick transaction to abort based on:

     * Age (younger is preferred victim).
     * Resources used (less costly one).
     * Priority.

3. **Restart Transaction**

   * Aborted transaction is restarted later.

ðŸ‘‰ Example in CodingGita DB:

* T1 is updating **100 student records**, T2 only updating **1 student record**.
* T2 is chosen as victim (less costly to rollback).

---

## 5. Deadlock vs Starvation

* **Deadlock** â†’ Circular wait, no one can proceed. Permanent.
* **Starvation** â†’ Transaction keeps waiting because others keep getting priority. Not permanent but unfair.

ðŸ‘‰ Example:

* If Faculty Câ€™s small query keeps waiting because Faculty Aâ€™s updates always get locks â†’ **starvation**.

---

## 6. SQL Deadlock Simulation

### Session 1 (T1 â€“ Faculty A)

```sql
BEGIN;
UPDATE Student SET City = 'Ahmedabad' WHERE RollNo = 101;  -- Locks City
-- Wants Marks next
```

### Session 2 (T2 â€“ Faculty B)

```sql
BEGIN;
UPDATE Enrollment SET Marks = 95 WHERE RollNo = 101;  -- Locks Marks
-- Wants City next
```

ðŸ‘‰ Now both wait â†’ **Deadlock**.
ðŸ‘‰ DBMS detects and aborts one automatically (usually younger).

---

## 7. Summary

* Deadlock occurs when transactions wait indefinitely due to circular locking.
* **Coffmanâ€™s conditions**: Mutual Exclusion, Hold & Wait, No Preemption, Circular Wait.
* **Prevention**: Timeout, Wait-Die, Wound-Wait.
* **Detection**: Wait-for Graph cycle detection.
* **Recovery**: Victim rollback, restart later.
* **Starvation â‰  Deadlock** â†’ starvation is indefinite waiting but not permanent.
* In **CodingGita DB**, deadlock can occur when **faculty and admin both try updating same student details** â€” DBMS must handle via prevention or detection.

---
