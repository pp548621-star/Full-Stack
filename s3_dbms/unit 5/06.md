# Timestamp-Based Concurrency Control

## 1. Introduction

* Unlike **lock-based protocols**, which may cause **deadlocks**, timestamp-based control uses **timestamps** to order transactions.
* Each transaction gets a unique **timestamp (TS)** at start time.
* The system ensures that transactions execute in **timestamp order**, guaranteeing serializability.

ðŸ‘‰ Think of it like **giving tokens in a queue** â†’ older tokens (earlier timestamps) have higher priority.

---

## 2. Timestamps in DBMS

* A **timestamp** is usually the **system clock value** when a transaction starts.
* Each data item (like Marks, City) has two timestamps:

  * **Read\_TS(X)** â†’ largest timestamp of any transaction that successfully read X.
  * **Write\_TS(X)** â†’ largest timestamp of any transaction that successfully wrote X.

ðŸ‘‰ These help check whether a new read/write is valid or should be rejected (rolled back).

---

## 3. Rules of Timestamp Ordering

For transaction **Ti** with timestamp TS(Ti):

1. **Read(X) rule**

   * If TS(Ti) < Write\_TS(X) â†’ reject (Ti is too old, another newer transaction already wrote X).
   * Else â†’ allow read, update Read\_TS(X).

2. **Write(X) rule**

   * If TS(Ti) < Read\_TS(X) â†’ reject (Ti is too old, newer transaction already read X).
   * If TS(Ti) < Write\_TS(X) â†’ reject (newer value already written).
   * Else â†’ allow write, update Write\_TS(X).

ðŸ‘‰ This prevents conflicts by ensuring transactions **never go backward in time**.

---

## 4. Example 1 â€“ CodingGita Marks Update

Two faculty members update **Marks** of RollNo 101.

* **T1** (older transaction, TS=10) â†’ wants to write Marks=90.
* **T2** (newer transaction, TS=20) â†’ wants to write Marks=95.

Steps:

1. T1 writes first â†’ Write\_TS(Marks)=10.
2. T2 tries â†’ TS(T2)=20 > Write\_TS(Marks)=10 â†’ allowed. Marks=95.

ðŸ‘‰ Final result = Marks=95 (latest transaction wins).
ðŸ‘‰ No deadlock since ordering is timestamp-based.

---

## 5. Example 2 â€“ Rejecting Old Write

* **T1** (TS=5) reads Marks=80.
* **T2** (TS=15) writes Marks=90 â†’ Write\_TS(Marks)=15.
* Later T1 (older) tries to write Marks=85.

Check rule:

* TS(T1)=5 < Write\_TS(Marks)=15 â†’ reject T1â€™s write.
* T1 is aborted & restarted with a new timestamp.

ðŸ‘‰ Prevents overwriting of newer values with old ones.

---

## 6. Example 3 â€“ Preventing Inconsistent Reads

* **T1** (TS=10) writes Marks=85 â†’ Write\_TS(Marks)=10.
* **T2** (TS=5) tries to read Marks after this.

Check rule:

* TS(T2)=5 < Write\_TS(Marks)=10 â†’ reject T2â€™s read.
* T2 is aborted & restarted with a newer timestamp.

ðŸ‘‰ Prevents an old transaction from reading a value that didnâ€™t exist at its logical time.

---

## 7. Advantages of Timestamp Ordering

1. **No Deadlocks**

   * No waiting â†’ if conflict occurs, one transaction is aborted immediately.
   * Unlike locks, no cycles (deadlocks) possible.

2. **Ensures Serializability**

   * Transactions always follow **timestamp order**.

3. **Fairness**

   * Older transactions have priority (unless restarted).

---

## 8. Disadvantages

1. **Starvation Possible**

   * A transaction may keep aborting if it gets a low timestamp and conflicts with many newer transactions.
   * Example: A long-running report in CodingGita DB keeps restarting because newer updates come in.

2. **Rollback Overhead**

   * Aborted transactions must restart â†’ wastes resources.

---

## 9. CodingGita Case Study

### Scenario â€“ Fee Payment & Marks Update

* **T1 (TS=100)** â†’ Updates Fee Payment for RollNo 101.
* **T2 (TS=120)** â†’ Updates Marks for RollNo 101.

Since both touch different attributes, both succeed.

But if:

* **T1 (TS=100)** reads Marks.
* **T2 (TS=120)** writes Marks=95.
* Later T1 (TS=100) tries to write Marks=90.

Check: TS(T1)=100 < Write\_TS(Marks)=120 â†’ reject T1â€™s write.

ðŸ‘‰ Ensures the database reflects the correct chronological order.

---

## 10. Summary

* **Timestamp-based concurrency** replaces locks with transaction timestamps.
* Each data item has **Read\_TS(X)** and **Write\_TS(X)**.
* Rules:

  * Reject old reads/writes that conflict with newer actions.
* **Advantages**: No deadlock, maintains serializability.
* **Disadvantages**: Starvation, repeated rollbacks.
* In **CodingGita DB**, timestamp ordering ensures that **faculty updates to marks, fees, and student data** always follow a consistent timeline without deadlocks.

---
