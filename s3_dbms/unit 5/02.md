# Concurrency Control

## 1. Introduction

* **Concurrency** = multiple users accessing the same database **at the same time**.
* Without proper control, this leads to **data inconsistencies**.
* **Concurrency Control** ensures correctness when transactions run simultaneously.

👉 Example in **CodingGita Portal**:

* Two faculty members updating the same student’s marks at the same time.
* One admin updating fee payment while another checking reports.
* Without concurrency control, updates might get lost or incorrect results may appear.

---

## 2. The Need for Concurrency Control

* Modern DBs must handle **hundreds or thousands of simultaneous users**.
* Without concurrency control:

  * **Lost updates** → one transaction overwrites another.
  * **Dirty reads** → a transaction reads uncommitted changes.
  * **Non-repeatable reads** → repeated reads give different results.
  * **Phantom reads** → new rows appear in between repeated queries.

---

## 3. Concurrency Problems (with CodingGita Examples)

---

### 3.1 Lost Update Problem

Occurs when two transactions update the same data and the first update is lost.

**Scenario**:

* **T1**: Faculty A updates RollNo 101 marks from 80 → 85.
* **T2**: Faculty B updates RollNo 101 marks from 80 → 90.

**Schedule**:

| Step | Transaction 1 (T1) | Transaction 2 (T2) | Marks Value |
| ---- | ------------------ | ------------------ | ----------- |
| 1    | Read Marks = 80    |                    | 80          |
| 2    |                    | Read Marks = 80    | 80          |
| 3    | Update Marks = 85  |                    | 85          |
| 4    |                    | Update Marks = 90  | 90          |

👉 Final Marks = **90** → T1’s update is lost.

---

### 3.2 Dirty Read Problem

Occurs when a transaction reads data that was updated but **not yet committed** by another transaction.

**Scenario**:

* **T1**: Admin updates fee payment = Paid. (Not committed yet).
* **T2**: Student queries fee status and sees **Paid**.
* **T1** rolls back → but student already saw wrong info.

**Schedule**:

| Step | Transaction 1 (T1)   | Transaction 2 (T2) | Fee Status         |
| ---- | -------------------- | ------------------ | ------------------ |
| 1    | Update Fee = Paid    |                    | Paid (Uncommitted) |
| 2    |                      | Read Fee = Paid    | Paid               |
| 3    | Rollback (Fee = Due) |                    | Due                |

👉 T2 saw **dirty (uncommitted) data**.

---

### 3.3 Non-Repeatable Read

Occurs when the same query gives **different results** in one transaction because another transaction updated the data.

**Scenario**:

* **T1**: Student checks marks → sees 80.
* **T2**: Faculty updates marks 80 → 95 and commits.
* **T1**: Checks marks again → sees 95.

👉 Same query in T1 gives different results.

---

### 3.4 Phantom Read

Occurs when new rows appear in a repeated query due to another transaction’s insert.

**Scenario**:

* **T1**: Admin queries students in Semester 3 → gets 40 students.
* **T2**: Inserts a new student in Semester 3 and commits.
* **T1**: Queries again → gets 41 students.

👉 A “phantom” row appeared.

---

## 4. Concurrency Control Solutions

### 4.1 Locking

* Prevents multiple transactions from accessing same data simultaneously.
* Shared Lock → allows read, blocks write.
* Exclusive Lock → allows read/write by one transaction only.

👉 Faculty A and Faculty B cannot update same student’s marks at the same time if exclusive lock is applied.

---

### 4.2 Isolation Levels

SQL provides **transaction isolation levels** to control concurrency:

1. **Read Uncommitted** → allows dirty reads (fastest, least safe).
2. **Read Committed** → no dirty reads (default in many DBs).
3. **Repeatable Read** → no dirty/non-repeatable reads, but phantoms possible.
4. **Serializable** → safest, prevents all problems (but slowest).

👉 CodingGita DB might use **Read Committed** for performance, but **Serializable** during financial transactions.

---

### 4.3 Timestamp Ordering

* Each transaction gets a timestamp.
* Conflicts resolved by **allowing older transaction first**.

---

### 4.4 Optimistic Concurrency

* Assume conflicts are rare.
* Validate changes before commit.
* Used in **modern web apps** where reads >> writes.

---

## 5. Example – Using Transaction Control in SQL

```sql
-- Session 1: Faculty A
BEGIN;
UPDATE Enrollment SET Marks = 85 WHERE RollNo = 101;
-- not committed yet

-- Session 2: Faculty B
SELECT Marks FROM Enrollment WHERE RollNo = 101;
-- In READ COMMITTED → sees old value
-- In READ UNCOMMITTED → may see 85 (dirty read)
```

---

## 6. Summary

* **Concurrency Control** ensures multiple users can safely use DB at the same time.
* Problems without control:

  * Lost Updates
  * Dirty Reads
  * Non-Repeatable Reads
  * Phantom Reads
* Solutions:

  * **Locks** (Shared, Exclusive).
  * **Isolation Levels** (Read Uncommitted → Serializable).
  * **Timestamp Ordering**.
  * **Optimistic Concurrency**.
* In **CodingGita DB**, concurrency control ensures that **marks, fees, enrollments** remain consistent even under heavy usage.

---
