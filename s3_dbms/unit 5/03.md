# Serializability

## 1. Introduction

* In a database, **many transactions run concurrently** for performance.
* But concurrency may lead to **conflicts** (lost update, dirty read, etc.).
* To ensure correctness, we check if the **interleaved schedule of transactions** is equivalent to a **serial schedule**.

ðŸ‘‰ A **schedule** = order in which operations (Read, Write) of transactions are executed.
ðŸ‘‰ **Serializability** = condition where a concurrent schedule behaves **as if transactions ran one after another** (serially).

---

## 2. Types of Serializability

1. **Conflict Serializability**

   * Based on **conflicting operations** (Read/Write).
   * If a schedule can be transformed into a serial schedule by **swapping non-conflicting operations**, it is **conflict-serializable**.

2. **View Serializability**

   * Based on **final output equivalence**.
   * A schedule is view-serializable if it produces the **same final result** as some serial schedule.

---

## 3. Conflicting Operations

Two operations are **in conflict** if:

1. They belong to **different transactions**.
2. They operate on the **same data item**.
3. At least one of them is a **Write**.

ðŸ‘‰ Conflicts:

* Readâ€“Write (RW)
* Writeâ€“Read (WR)
* Writeâ€“Write (WW)

Non-conflicts:

* Readâ€“Read (RR)

---

## 4. Example 1 â€“ Conflict Serializability (CodingGita Marks Update)

Transactions:

* **T1**: Faculty A updates student marks.
* **T2**: Faculty B reads marks.

**Schedule S:**

```
T1: Read(Marks)
T2: Read(Marks)
T1: Write(Marks=90)
T2: Write(Marks=95)
```

* Conflict operations:

  * T1 Write vs T2 Read â†’ conflict
  * T1 Write vs T2 Write â†’ conflict

Graph (Precedence Graph):

* T1 â†’ T2 (Write before Read).
* T2 â†’ T1 (Write after Write).

Cycle exists â†’ **Not Conflict-Serializable**.

ðŸ‘‰ Final result depends on order. Unsafe.

---

## 5. Example 2 â€“ Conflict-Serializable Schedule

Transactions:

* **T1**: Update Student Marks.
* **T2**: Update Student City.

**Schedule S:**

```
T1: Read(Marks)
T1: Write(Marks=85)
T2: Read(City)
T2: Write(City='Rajkot')
```

* No conflicts (different attributes).
* Graph has no cycle â†’ **Conflict-Serializable**.

ðŸ‘‰ Equivalent to serial order T1 â†’ T2.

---

## 6. View Serializability

Sometimes, a schedule may not be conflict-serializable but still **produces the same result as a serial schedule**.

### Conditions for View Serializability

1. Both schedules must read the same initial values.
2. Both must produce the same final writes.
3. Read-from relationships must match.

---

### Example 3 â€“ View Serializable but Not Conflict Serializable

**Schedule S:**

```
T1: Write(A=50)
T2: Read(A)
T2: Write(A=60)
```

* Conflict serializability check â†’ Not possible (conflicts).
* But **final result = A=60** (same as if T2 ran after T1).
* Hence, it is **View Serializable**.

---

## 7. Precedence (Serialization) Graph

* Used to test **conflict serializability**.
* Steps:

  1. Create a node for each transaction.
  2. Add directed edge Ti â†’ Tj if Tiâ€™s operation conflicts with Tjâ€™s operation.
  3. If the graph has **no cycle**, schedule is conflict-serializable.

ðŸ‘‰ Example:

Transactions:

* T1: Write(A)
* T2: Read(A), Write(A)

Schedule:

```
T1: Write(A)
T2: Read(A)
T2: Write(A)
```

Graph:

* T1 â†’ T2 (Write before Read).
  No cycle â†’ **Conflict-Serializable**.

---

## 8. CodingGita Example â€“ Enrollment Table

* **T1**: Faculty updates marks of RollNo 101 â†’ 92.
* **T2**: Faculty updates marks of RollNo 102 â†’ 85.

**Schedule S:**

```
T1: Read(Marks101)
T1: Write(Marks101=92)
T2: Read(Marks102)
T2: Write(Marks102=85)
```

* No conflicts (different students).
* Graph â†’ no cycle.
* Schedule is **Conflict-Serializable**.

ðŸ‘‰ Safe even though executed concurrently.

---

## 9. Summary

* **Serializability** ensures concurrent schedules behave like serial ones.
* **Conflict Serializability** â†’ checked using conflicts + precedence graph.
* **View Serializability** â†’ checked using final result equivalence.
* **Conflict serializable â‡’ View serializable** but not vice versa.
* In **CodingGita DB**, serializability ensures that concurrent student updates, fee transactions, or course enrollments remain **consistent and safe**.

---
