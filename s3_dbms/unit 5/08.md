# Database Recovery Management

---

## 1. Introduction

* In real-world systems, **failures are inevitable** â€” power cuts, system crashes, disk corruption, software bugs.
* A DBMS must ensure **no data is lost** and the database remains **consistent** after failure.
* **Recovery Management** = techniques that restore the database to the **last consistent state**.

ðŸ‘‰ In **CodingGita DB**:

* If power fails while inserting a studentâ€™s fee record, DBMS ensures either:

  1. Entire transaction is rolled back (fee not deducted).
  2. Or fully committed (fee deducted + receipt stored).
* But never a **partial update** (fee deducted but no receipt).

---

## 2. Types of Failures

### 2.1 Transaction Failure

* Logical error (division by zero, invalid data).
* System error (transaction aborted).

### 2.2 System Crash

* Power failure, OS crash.
* Main memory lost, but disk intact.

### 2.3 Disk Failure

* Hardware crash â†’ disk lost.
* Requires restore from **backup**.

---

## 3. Recovery Techniques

### 3.1 Log-Based Recovery

* DBMS maintains a **log file** that records every update.
* Log entries have:

  * Transaction ID.
  * Data item.
  * Old value.
  * New value.

#### (a) Write-Ahead Logging (WAL) Rule

* Log must be written **before** actual data is written to disk.
* Ensures recovery can undo/redo changes.

#### Example â€“ CodingGita Marks Update

Transaction T1 updates Marks of RollNo 101 from 80 â†’ 90.

Log entry:

```
<T1, Marks, 80, 90>
```

If crash occurs:

* If T1 committed â†’ **Redo** (apply new value 90).
* If T1 not committed â†’ **Undo** (restore old value 80).

---

### 3.2 Deferred Update (No-Undo/Redo)

* Updates applied to log only until COMMIT.
* Only at COMMIT, actual DB is updated.
* On crash: no undo required.

ðŸ‘‰ Example: Fee update is written to log. Actual DB updated only when COMMIT happens.

---

### 3.3 Immediate Update (Undo/Redo)

* Updates are immediately applied to DB + log.
* On crash:

  * If transaction committed â†’ redo.
  * If transaction uncommitted â†’ undo.

ðŸ‘‰ Example: Marks update written immediately, but if crash before commit â†’ rollback using old values.

---

### 3.4 Shadow Paging

* DBMS keeps **two copies** of data:

  * Shadow page (original stable version).
  * Current page (being updated).
* At commit â†’ current page replaces shadow.
* On crash â†’ discard current page, shadow remains safe.

ðŸ‘‰ Example: While updating Student table, shadow copy ensures original data remains untouched until commit.

---

## 4. Checkpoints

* **Checkpoint** = savepoint in DB recovery.
* At checkpoint, DBMS writes all updates to disk and clears part of the log.
* During recovery:

  * Start from last checkpoint instead of beginning of log.
* Reduces recovery time.

ðŸ‘‰ Example:

* CodingGita DB checkpoint every 5 minutes.
* If crash at 10:02 â†’ recovery restarts from 10:00 checkpoint.

---

## 5. Recovery Steps

When DB restarts after crash:

1. **Identify committed transactions** â†’ redo them.
2. **Identify uncommitted transactions** â†’ undo them.

---

## 6. Backup & Restore

* **Backup** = copy of DB at a safe location (disk/tape/cloud).
* **Restore** = recover DB using backup + log.

ðŸ‘‰ In CodingGita:

* Daily backup at 2:00 AM.
* If system fails at 4:00 PM â†’ restore last backup + apply logs of the day.

---

## 7. SQL Commands for Recovery

### 7.1 COMMIT

```sql
COMMIT;   -- Save changes permanently
```

### 7.2 ROLLBACK

```sql
ROLLBACK;  -- Undo current transaction
```

### 7.3 SAVEPOINT

```sql
SAVEPOINT sp1;  
UPDATE Student SET City = 'Rajkot' WHERE RollNo = 101;  
ROLLBACK TO sp1;  -- Undo only part of transaction
```

### 7.4 Backup (Oracle/MySQL Example)

```bash
mysqldump -u root -p codinggitaDB > backup.sql
```

### 7.5 Restore

```bash
mysql -u root -p codinggitaDB < backup.sql
```

---

## 8. CodingGita Case Study â€“ Fee Transaction

Suppose student Krishna pays fees:

1. Transaction starts.
2. `FeePayment` record inserted.
3. `Receipt` generated.
4. Crash occurs before COMMIT.

**Recovery:**

* Log shows transaction incomplete.
* DBMS rolls back â†’ no partial fee deduction.
* Student must retry payment.

---

## 9. Summary

* Recovery management ensures DB correctness after failures.
* **Failures:** transaction, system, disk.
* **Techniques:**

  * Log-based recovery (Undo/Redo).
  * Shadow paging.
* **Checkpoints** reduce recovery time.
* **Backup/Restore** protect against disk failures.
* In **CodingGita DB**, recovery ensures student fees, marks, and enrollments are never lost or partially updated.

---
